module ParserTest (parserTests) where

import AST
import Test.Hspec (Spec, describe, it, shouldBe)
import Token

infos :: [Token] -> [TokenInfo]
infos = map (`TokenInfo` 0)

parserTests :: Ast -> Spec
parserTests ast = do
    testClass ast
    testAttributeNoInit ast
    testAttributeInit ast
    testMethod ast
    testLiteralId ast
    testArithmetic ast
    testRelational ast
    testAssignment ast
    testNewIsVoid ast
    testDispatch ast
    testIf ast
    testWhile ast
    testLet ast
    testCase ast
    testBlock ast
    testStringSpecialChars ast
    testBig ast

testClass :: Ast -> Spec
testClass ast = do
    describe "Parser" $ do
        it "should ast class" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, RightSquirly, SemiColon, Class, Type "B", Inherits, Type "A", LeftSquirly, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [],ClassDefinition (TokenInfo {token = Type "B", offset = 0}) (Just (TokenInfo {token = Type "A", offset = 0})) []])

testAttributeNoInit :: Ast -> Spec
testAttributeNoInit ast = do
    describe "Parser" $ do
        it "should ast attribute no init" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "x", Colon, Type "SELF_TYPE", SemiColon, RightSquirly, SemiColon, Class, Type "B", Inherits, Type "A", LeftSquirly, Ident "y", Colon, Type "Int", SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "SELF_TYPE", offset = 0}) Nothing],ClassDefinition (TokenInfo {token = Type "B", offset = 0}) (Just (TokenInfo {token = Type "A", offset = 0})) [AttributeDefinition (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) Nothing]])

testAttributeInit :: Ast -> Spec
testAttributeInit ast = do
    describe "Parser" $ do
        it "should ast attribute init" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "x", Colon, Type "SELF_TYPE", SemiColon, RightSquirly, SemiColon, Class, Type "B", Inherits, Type "A", LeftSquirly, Ident "y", Colon, Type "Int", Assign, Integer 0, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "SELF_TYPE", offset = 0}) Nothing],ClassDefinition (TokenInfo {token = Type "B", offset = 0}) (Just (TokenInfo {token = Type "A", offset = 0})) [AttributeDefinition (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0})))]])

testMethod :: Ast -> Spec
testMethod ast = do
    describe "Parser" $ do
        it "should ast method" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "x", Colon, Type "SELF_TYPE", SemiColon, Ident "f", LeftParen, RightParen, Colon, Type "Object", LeftSquirly, Integer 0, RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type "B", Inherits, Type "A", LeftSquirly, Ident "y", Colon, Type "Int", Assign, Integer 0, SemiColon, Ident "g", LeftParen, Ident "x", Colon, Type "Int", Comma, Ident "y", Colon, Type "Bool", RightParen, Colon, Type "Int", LeftSquirly, Integer 0, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "SELF_TYPE", offset = 0}) Nothing,MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [] (TokenInfo {token = Type "Object", offset = 0}) (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))],ClassDefinition (TokenInfo {token = Type "B", offset = 0}) (Just (TokenInfo {token = Type "A", offset = 0})) [AttributeDefinition (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))),MethodDefinition (TokenInfo {token = Ident "g", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}),Formal (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Bool", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))]])

testLiteralId :: Ast -> Spec
testLiteralId ast = do
    describe "Parser" $ do
        it "should ast literal" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "n", Colon, Type "Int", Assign, Integer 0, SemiColon, Ident "s", Colon, Type "String", Assign, String "abc", SemiColon, Ident "b", Colon, Type "Bool", Assign, Boolean False, SemiColon, Ident "c", Colon, Type "Bool", Assign, Ident "b", SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "s", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "abc", offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "b", offset = 0}) (TokenInfo {token = Type "Bool", offset = 0}) (Just (BoolLiteral (TokenInfo {token = Boolean False, offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "c", offset = 0}) (TokenInfo {token = Type "Bool", offset = 0}) (Just (IdentStatement (TokenInfo {token = Ident "b", offset = 0})))]])

testArithmetic :: Ast -> Spec
testArithmetic ast = do
    describe "Parser" $ do
        it "should ast arithmetic" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "n", Colon, Type "Int", Assign, Integer 1, Plus, Integer 2, Asterisk, LeftParen, Integer 3, Plus, Integer 4, RightParen, Slash, LeftParen, Integer 5, Minus, Tilde, Integer 6, RightParen, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (AddStatement (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})) (DivStatement (MulStatement (IntegerLiteral (TokenInfo {token = Integer 2, offset = 0})) (ParenStatement (AddStatement (IntegerLiteral (TokenInfo {token = Integer 3, offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 4, offset = 0}))))) (ParenStatement (SubStatement (IntegerLiteral (TokenInfo {token = Integer 5, offset = 0})) (NegationStatement (IntegerLiteral (TokenInfo {token = Integer 6, offset = 0}))))))))]])

testRelational :: Ast -> Spec
testRelational ast = do
    describe "Parser" $ do
        it "should ast relational" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "n", Colon, Type "Int", SemiColon, Ident "b", Colon, Type "Bool", Assign, Not, Integer 2, LessEqual, Ident "n", SemiColon, Ident "c", Colon, Type "Bool", Assign, Integer 2, LessThan, Ident "n", Plus, Integer 1, Equal, Boolean False, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) Nothing,AttributeDefinition (TokenInfo {token = Ident "b", offset = 0}) (TokenInfo {token = Type "Bool", offset = 0}) (Just (NotStatement (LessThanOrEqualStatement (IntegerLiteral (TokenInfo {token = Integer 2, offset = 0})) (IdentStatement (TokenInfo {token = Ident "n", offset = 0}))))),AttributeDefinition (TokenInfo {token = Ident "c", offset = 0}) (TokenInfo {token = Type "Bool", offset = 0}) (Just (EqualStatement (LessThanStatement (IntegerLiteral (TokenInfo {token = Integer 2, offset = 0})) (AddStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})))) (BoolLiteral (TokenInfo {token = Boolean False, offset = 0}))))]])

testAssignment :: Ast -> Spec
testAssignment ast = do
    describe "Parser" $ do
        it "should ast assignment" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "x", Colon, Type "Int", SemiColon, Ident "f", LeftParen, Ident "y", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, Ident "x", Assign, Ident "y", RightSquirly, SemiColon, Ident "f", LeftParen, Ident "y", Colon, Type "Int", Comma, Ident "z", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, Ident "x", Assign, Ident "y", Assign, Ident "z", RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) Nothing,MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (AssignStatement (TokenInfo {token = Ident "x", offset = 0}) (IdentStatement (TokenInfo {token = Ident "y", offset = 0}))),MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}),Formal (TokenInfo {token = Ident "z", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (AssignStatement (TokenInfo {token = Ident "x", offset = 0}) (AssignStatement (TokenInfo {token = Ident "y", offset = 0}) (IdentStatement (TokenInfo {token = Ident "z", offset = 0}))))]])

testNewIsVoid :: Ast -> Spec
testNewIsVoid ast = do
    describe "Parser" $ do
        it "should ast new isvoid" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, RightParen, Colon, Type "Bool", LeftSquirly, Not, IsVoid, New, Type "A", RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [] (TokenInfo {token = Type "Bool", offset = 0}) (NotStatement (IsVoidStatement (NewStatement (TokenInfo {token = Type "A", offset = 0}))))]])

testDispatch :: Ast -> Spec
testDispatch ast = do
    describe "Parser" $ do
        it "should ast dispatch" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "Bool", LeftSquirly, Ident "f", LeftParen, Ident "x", Plus, Integer 1, RightParen, RightSquirly, SemiColon, Ident "g", LeftParen, Ident "x", Colon, Type "Int", Comma, Ident "y", Colon, Type "Int", RightParen, Colon, Type "Bool", LeftSquirly, Ident "self", Dot, Ident "g", LeftParen, Ident "x", Plus, Integer 1, Comma, Ident "y", Plus, Integer 1, RightParen, RightSquirly, SemiColon, Ident "h", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "A", LeftSquirly, New, Type "A", At, Type "A", Dot, Ident "h", LeftParen, Ident "x", Plus, Integer 1, RightParen, Dot, Ident "h", LeftParen, Ident "x", Plus, Integer 2, RightParen, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Bool", offset = 0}) (MethodCall Nothing Nothing (TokenInfo {token = Ident "f", offset = 0}) [AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))]),MethodDefinition (TokenInfo {token = Ident "g", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}),Formal (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Bool", offset = 0}) (MethodCall (Just (IdentStatement (TokenInfo {token = Ident "self", offset = 0}))) Nothing (TokenInfo {token = Ident "g", offset = 0}) [AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})),AddStatement (IdentStatement (TokenInfo {token = Ident "y", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))]),MethodDefinition (TokenInfo {token = Ident "h", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "A", offset = 0}) (MethodCall (Just (MethodCall (Just (NewStatement (TokenInfo {token = Type "A", offset = 0}))) (Just (TokenInfo {token = Type "A", offset = 0})) (TokenInfo {token = Ident "h", offset = 0}) [AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))])) Nothing (TokenInfo {token = Ident "h", offset = 0}) [AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 2, offset = 0}))])]])

testIf :: Ast -> Spec
testIf ast = do
    describe "Parser" $ do
        it "should ast if" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, If, Ident "x", LessEqual, Integer 5, Then, Ident "x", Else, Ident "x", Plus, Integer 1, Fi, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (IfStatement (LessThanOrEqualStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 5, offset = 0}))) (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))))]])

testWhile :: Ast -> Spec
testWhile ast = do
    describe "Parser" $ do
        it "should ast while" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "Object", LeftSquirly, While, Integer 0, LessThan, Ident "x", Loop, Ident "x", Assign, Ident "x", Minus, Integer 1, Pool, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Object", offset = 0}) (WhileStatement (LessThanStatement (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0})) (IdentStatement (TokenInfo {token = Ident "x", offset = 0}))) (AssignStatement (TokenInfo {token = Ident "x", offset = 0}) (SubStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})))))]])

testLet :: Ast -> Spec
testLet ast = do
    describe "Parser" $ do
        it "should ast let" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, Let, Ident "x", Colon, Type "Int", Assign, Ident "x", Plus, Integer 1, Comma, Ident "y", Colon, Type "Int", Assign, Ident "x", Plus, Integer 1, In, Ident "x", RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (LetStatement [VariableDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})))),VariableDefinition (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))))] (IdentStatement (TokenInfo {token = Ident "x", offset = 0})))]])

testCase :: Ast -> Spec
testCase ast = do
    describe "Parser" $ do
        it "should ast case" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Object", RightParen, Colon, Type "String", LeftSquirly, Case, Ident "x", Of, Ident "s", Colon, Type "String", Results, String "String", SemiColon, Ident "i", Colon, Type "Int", Results, String "Int", SemiColon, Ident "o", Colon, Type "Object", Results, String "Oops", SemiColon, Esac, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Object", offset = 0})] (TokenInfo {token = Type "String", offset = 0}) (CaseStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) [CaseOfDefinition (TokenInfo {token = Ident "s", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (StringLiteral (TokenInfo {token = String "String", offset = 0})),CaseOfDefinition (TokenInfo {token = Ident "i", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (StringLiteral (TokenInfo {token = String "Int", offset = 0})),CaseOfDefinition (TokenInfo {token = Ident "o", offset = 0}) (TokenInfo {token = Type "Object", offset = 0}) (StringLiteral (TokenInfo {token = String "Oops", offset = 0}))])]])

testBlock :: Ast -> Spec
testBlock ast = do
    describe "Parser" $ do
        it "should ast block" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "f", LeftParen, Ident "x", Colon, Type "Int", RightParen, Colon, Type "String", LeftSquirly, LeftSquirly, Ident "x", Assign, Ident "x", Plus, Integer 1, SemiColon, String "Done!", SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [MethodDefinition (TokenInfo {token = Ident "f", offset = 0}) [Formal (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "String", offset = 0}) (BlockStatement [AssignStatement (TokenInfo {token = Ident "x", offset = 0}) (AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))),StringLiteral (TokenInfo {token = String "Done!", offset = 0})])]])

testStringSpecialChars :: Ast -> Spec
testStringSpecialChars ast = do
    describe "Parser" $ do
        it "should ast string with special chars" $
            do
                ast $ infos [Class, Type "A", LeftSquirly, Ident "s1", Colon, Type "String", Assign, String "ab\tcd", SemiColon, Ident "s2", Colon, Type "String", Assign, String "ab\ncd", SemiColon, Ident "s3", Colon, Type "String", Assign, String "ab\ncd", SemiColon, Ident "s4", Colon, Type "String", Assign, String "ab\\cd", SemiColon, Ident "s5", Colon, Type "String", Assign, String "abzcd", SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "A", offset = 0}) Nothing [AttributeDefinition (TokenInfo {token = Ident "s1", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "ab\tcd", offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "s2", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "ab\ncd", offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "s3", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "ab\ncd", offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "s4", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "ab\\cd", offset = 0}))),AttributeDefinition (TokenInfo {token = Ident "s5", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "abzcd", offset = 0})))]])

testBig :: Ast -> Spec
testBig ast = do
    describe "Parser" $ do
        it "should ast big text" $
            do
                ast $ infos [Class, Type "List", Inherits, Type "IO", LeftSquirly, Ident "elem", Colon, Type "Object", SemiColon, Ident "next", Colon, Type "List", SemiColon, Ident "init", LeftParen, Ident "e", Colon, Type "Object", Comma, Ident "n", Colon, Type "List", RightParen, Colon, Type "List", LeftSquirly, LeftSquirly, Ident "elem", Assign, Ident "e", SemiColon, Ident "next", Assign, Ident "n", SemiColon, Ident "self", SemiColon, RightSquirly, RightSquirly, SemiColon, Ident "print", LeftParen, RightParen, Colon, Type "IO", LeftSquirly, Let, Ident "str", Colon, Type "String", Assign, Case, Ident "elem", Of, Ident "s", Colon, Type "String", Results, Ident "s", SemiColon, Ident "n", Colon, Type "Int", Results, New, Type "A2I", Dot, Ident "i2a", LeftParen, Ident "n", RightParen, SemiColon, Ident "o", Colon, Type "Object", Results, LeftSquirly, Ident "abort", LeftParen, RightParen, SemiColon, String "", SemiColon, RightSquirly, SemiColon, Esac, In, LeftSquirly, Ident "out_string", LeftParen, Ident "str", Dot, Ident "concat", LeftParen, String " ", RightParen, RightParen, SemiColon, If, LeftParen, IsVoid, Ident "next", RightParen, Then, Ident "out_string", LeftParen, String "\n", RightParen, Else, Ident "next", Dot, Ident "print", LeftParen, RightParen, Fi, SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type "Main", Inherits, Type "IO", LeftSquirly, Ident "main", LeftParen, RightParen, Colon, Type "Object", LeftSquirly, LeftSquirly, Let, Ident "x", Colon, Type "Int", Assign, Integer 0, Comma, Ident "y", Colon, Type "String", Assign, String "!", Comma, Ident "z", Colon, Type "Int", Assign, Ident "x", Plus, Integer 2, Comma, Ident "empty", Colon, Type "List", Comma, Ident "list", Colon, Type "List", Assign, New, Type "List", Dot, Ident "init", LeftParen, Ident "x", Comma, New, Type "List", Dot, Ident "init", LeftParen, Ident "y", Comma, New, Type "List", Dot, Ident "init", LeftParen, Ident "z", Comma, Ident "empty", RightParen, RightParen, RightParen, In, Ident "list", Dot, Ident "print", LeftParen, RightParen, SemiColon, Let, Ident "n", Colon, Type "Int", Assign, Ident "out_string", LeftParen, String "Calcul\259m factorial pentru: ", RightParen, Dot, Ident "in_int", LeftParen, RightParen, In, LeftSquirly, Ident "out_string", LeftParen, String "Factorial recursiv: ", RightParen, Dot, Ident "out_int", LeftParen, Ident "fact_rec", LeftParen, Ident "n", RightParen, RightParen, Dot, Ident "out_string", LeftParen, String "\n", RightParen, SemiColon, Ident "out_string", LeftParen, String "Factorial iterativ: ", RightParen, Dot, Ident "out_int", LeftParen, Ident "fact_iter", LeftParen, Ident "n", RightParen, RightParen, Dot, Ident "out_string", LeftParen, String "\n", RightParen, SemiColon, RightSquirly, SemiColon, RightSquirly, RightSquirly, SemiColon, Ident "fact_rec", LeftParen, Ident "n", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, If, Ident "n", Equal, Integer 0, Then, Integer 1, Else, Ident "n", Asterisk, Ident "fact_rec", LeftParen, Ident "n", Minus, Integer 1, RightParen, Fi, RightSquirly, SemiColon, Ident "fact_iter", LeftParen, Ident "n", Colon, Type "Int", RightParen, Colon, Type "Int", LeftSquirly, Let, Ident "res", Colon, Type "Int", Assign, Integer 1, In, LeftSquirly, While, LeftParen, Not, LeftParen, Ident "n", Equal, Integer 0, RightParen, RightParen, Loop, LeftSquirly, Ident "res", Assign, Ident "res", Asterisk, Ident "n", SemiColon, Ident "n", Assign, Ident "n", Minus, Integer 1, SemiColon, RightSquirly, Pool, SemiColon, Ident "res", SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo {token = Type "List", offset = 0}) (Just (TokenInfo {token = Type "IO", offset = 0})) [AttributeDefinition (TokenInfo {token = Ident "elem", offset = 0}) (TokenInfo {token = Type "Object", offset = 0}) Nothing,AttributeDefinition (TokenInfo {token = Ident "next", offset = 0}) (TokenInfo {token = Type "List", offset = 0}) Nothing,MethodDefinition (TokenInfo {token = Ident "init", offset = 0}) [Formal (TokenInfo {token = Ident "e", offset = 0}) (TokenInfo {token = Type "Object", offset = 0}),Formal (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "List", offset = 0})] (TokenInfo {token = Type "List", offset = 0}) (BlockStatement [AssignStatement (TokenInfo {token = Ident "elem", offset = 0}) (IdentStatement (TokenInfo {token = Ident "e", offset = 0})),AssignStatement (TokenInfo {token = Ident "next", offset = 0}) (IdentStatement (TokenInfo {token = Ident "n", offset = 0})),IdentStatement (TokenInfo {token = Ident "self", offset = 0})]),MethodDefinition (TokenInfo {token = Ident "print", offset = 0}) [] (TokenInfo {token = Type "IO", offset = 0}) (LetStatement [VariableDefinition (TokenInfo {token = Ident "str", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (CaseStatement (IdentStatement (TokenInfo {token = Ident "elem", offset = 0})) [CaseOfDefinition (TokenInfo {token = Ident "s", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (IdentStatement (TokenInfo {token = Ident "s", offset = 0})),CaseOfDefinition (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (MethodCall (Just (NewStatement (TokenInfo {token = Type "A2I", offset = 0}))) Nothing (TokenInfo {token = Ident "i2a", offset = 0}) [IdentStatement (TokenInfo {token = Ident "n", offset = 0})]),CaseOfDefinition (TokenInfo {token = Ident "o", offset = 0}) (TokenInfo {token = Type "Object", offset = 0}) (BlockStatement [MethodCall Nothing Nothing (TokenInfo {token = Ident "abort", offset = 0}) [],StringLiteral (TokenInfo {token = String "", offset = 0})])]))] (BlockStatement [MethodCall Nothing Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [MethodCall (Just (IdentStatement (TokenInfo {token = Ident "str", offset = 0}))) Nothing (TokenInfo {token = Ident "concat", offset = 0}) [StringLiteral (TokenInfo {token = String " ", offset = 0})]],IfStatement (ParenStatement (IsVoidStatement (IdentStatement (TokenInfo {token = Ident "next", offset = 0})))) (MethodCall Nothing Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "\n", offset = 0})]) (MethodCall (Just (IdentStatement (TokenInfo {token = Ident "next", offset = 0}))) Nothing (TokenInfo {token = Ident "print", offset = 0}) [])]))],ClassDefinition (TokenInfo {token = Type "Main", offset = 0}) (Just (TokenInfo {token = Type "IO", offset = 0})) [MethodDefinition (TokenInfo {token = Ident "main", offset = 0}) [] (TokenInfo {token = Type "Object", offset = 0}) (BlockStatement [LetStatement [VariableDefinition (TokenInfo {token = Ident "x", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))),VariableDefinition (TokenInfo {token = Ident "y", offset = 0}) (TokenInfo {token = Type "String", offset = 0}) (Just (StringLiteral (TokenInfo {token = String "!", offset = 0}))),VariableDefinition (TokenInfo {token = Ident "z", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (AddStatement (IdentStatement (TokenInfo {token = Ident "x", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 2, offset = 0})))),VariableDefinition (TokenInfo {token = Ident "empty", offset = 0}) (TokenInfo {token = Type "List", offset = 0}) Nothing,VariableDefinition (TokenInfo {token = Ident "list", offset = 0}) (TokenInfo {token = Type "List", offset = 0}) (Just (MethodCall (Just (NewStatement (TokenInfo {token = Type "List", offset = 0}))) Nothing (TokenInfo {token = Ident "init", offset = 0}) [IdentStatement (TokenInfo {token = Ident "x", offset = 0}),MethodCall (Just (NewStatement (TokenInfo {token = Type "List", offset = 0}))) Nothing (TokenInfo {token = Ident "init", offset = 0}) [IdentStatement (TokenInfo {token = Ident "y", offset = 0}),MethodCall (Just (NewStatement (TokenInfo {token = Type "List", offset = 0}))) Nothing (TokenInfo {token = Ident "init", offset = 0}) [IdentStatement (TokenInfo {token = Ident "z", offset = 0}),IdentStatement (TokenInfo {token = Ident "empty", offset = 0})]]]))] (MethodCall (Just (IdentStatement (TokenInfo {token = Ident "list", offset = 0}))) Nothing (TokenInfo {token = Ident "print", offset = 0}) []),LetStatement [VariableDefinition (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "Calcul\259m factorial pentru: ", offset = 0})])) Nothing (TokenInfo {token = Ident "in_int", offset = 0}) []))] (BlockStatement [MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "Factorial recursiv: ", offset = 0})])) Nothing (TokenInfo {token = Ident "out_int", offset = 0}) [MethodCall Nothing Nothing (TokenInfo {token = Ident "fact_rec", offset = 0}) [IdentStatement (TokenInfo {token = Ident "n", offset = 0})]])) Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "\n", offset = 0})],MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "Factorial iterativ: ", offset = 0})])) Nothing (TokenInfo {token = Ident "out_int", offset = 0}) [MethodCall Nothing Nothing (TokenInfo {token = Ident "fact_iter", offset = 0}) [IdentStatement (TokenInfo {token = Ident "n", offset = 0})]])) Nothing (TokenInfo {token = Ident "out_string", offset = 0}) [StringLiteral (TokenInfo {token = String "\n", offset = 0})]])]),MethodDefinition (TokenInfo {token = Ident "fact_rec", offset = 0}) [Formal (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (IfStatement (EqualStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0}))) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})) (MulStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (MethodCall Nothing Nothing (TokenInfo {token = Ident "fact_rec", offset = 0}) [SubStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0}))]))),MethodDefinition (TokenInfo {token = Ident "fact_iter", offset = 0}) [Formal (TokenInfo {token = Ident "n", offset = 0}) (TokenInfo {token = Type "Int", offset = 0})] (TokenInfo {token = Type "Int", offset = 0}) (LetStatement [VariableDefinition (TokenInfo {token = Ident "res", offset = 0}) (TokenInfo {token = Type "Int", offset = 0}) (Just (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})))] (BlockStatement [WhileStatement (ParenStatement (NotStatement (ParenStatement (EqualStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 0, offset = 0})))))) (BlockStatement [AssignStatement (TokenInfo {token = Ident "res", offset = 0}) (MulStatement (IdentStatement (TokenInfo {token = Ident "res", offset = 0})) (IdentStatement (TokenInfo {token = Ident "n", offset = 0}))),AssignStatement (TokenInfo {token = Ident "n", offset = 0}) (SubStatement (IdentStatement (TokenInfo {token = Ident "n", offset = 0})) (IntegerLiteral (TokenInfo {token = Integer 1, offset = 0})))]),IdentStatement (TokenInfo {token = Ident "res", offset = 0})]))]])
