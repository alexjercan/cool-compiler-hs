module ParserTest (parserTests) where

import AST
import Test.Hspec (Spec, describe, it, shouldBe)
import Token

parserTests :: Ast -> Spec
parserTests ast = do
    testClass ast
    testAttributeNoInit ast
    testAttributeInit ast
    testMethod ast
    testLiteralId ast
    testArithmetic ast
    testRelational ast
    testAssignment ast
    testNewIsVoid ast
    testDispatch ast
    testIf ast
    testWhile ast
    testLet ast
    testCase ast
    testBlock ast
    testStringSpecialChars ast
    testBig ast

testClass :: Ast -> Spec
testClass ast = do
    describe "Parser" $ do
        it "should ast class" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 19, value = "B"}), Inherits, Type (TokenInfo{offset = 30, value = "A"}), LeftSquirly, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [], ClassDefinition (Type (TokenInfo{offset = 19, value = "B"})) (Just (Type (TokenInfo{offset = 30, value = "A"}))) []])

testAttributeNoInit :: Ast -> Spec
testAttributeNoInit ast = do
    describe "Parser" $ do
        it "should ast attribute no init" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 39, value = "B"}), Inherits, Type (TokenInfo{offset = 50, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 58, value = "y"}), Colon, Type (TokenInfo{offset = 62, value = "Int"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "x"})) (Type (TokenInfo{offset = 18, value = "SELF_TYPE"})) Nothing], ClassDefinition (Type (TokenInfo{offset = 39, value = "B"})) (Just (Type (TokenInfo{offset = 50, value = "A"}))) [AttributeDefinition (Ident (TokenInfo{offset = 58, value = "y"})) (Type (TokenInfo{offset = 62, value = "Int"})) Nothing]])

testAttributeInit :: Ast -> Spec
testAttributeInit ast = do
    describe "Parser" $ do
        it "should ast attribute init" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 39, value = "B"}), Inherits, Type (TokenInfo{offset = 50, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 58, value = "y"}), Colon, Type (TokenInfo{offset = 62, value = "Int"}), Assign, Integer (TokenInfo{offset = 69, value = 0}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "x"})) (Type (TokenInfo{offset = 18, value = "SELF_TYPE"})) Nothing], ClassDefinition (Type (TokenInfo{offset = 39, value = "B"})) (Just (Type (TokenInfo{offset = 50, value = "A"}))) [AttributeDefinition (Ident (TokenInfo{offset = 58, value = "y"})) (Type (TokenInfo{offset = 62, value = "Int"})) (Just (IntegerLiteral (Integer (TokenInfo{offset = 69, value = 0}))))]])

testMethod :: Ast -> Spec
testMethod ast = do
    describe "Parser" $ do
        it "should ast method" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, Ident (TokenInfo{offset = 34, value = "f"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 40, value = "Object"}), LeftSquirly, Integer (TokenInfo{offset = 49, value = 0}), RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 64, value = "B"}), Inherits, Type (TokenInfo{offset = 75, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 83, value = "y"}), Colon, Type (TokenInfo{offset = 87, value = "Int"}), Assign, Integer (TokenInfo{offset = 94, value = 0}), SemiColon, Ident (TokenInfo{offset = 102, value = "g"}), LeftParen, Ident (TokenInfo{offset = 104, value = "x"}), Colon, Type (TokenInfo{offset = 108, value = "Int"}), Comma, Ident (TokenInfo{offset = 113, value = "y"}), Colon, Type (TokenInfo{offset = 117, value = "Bool"}), RightParen, Colon, Type (TokenInfo{offset = 125, value = "Int"}), LeftSquirly, Integer (TokenInfo{offset = 131, value = 0}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "x"})) (Type (TokenInfo{offset = 18, value = "SELF_TYPE"})) Nothing, MethodDefinition (Ident (TokenInfo{offset = 34, value = "f"})) [] (Type (TokenInfo{offset = 40, value = "Object"})) (IntegerLiteral (Integer (TokenInfo{offset = 49, value = 0})))], ClassDefinition (Type (TokenInfo{offset = 64, value = "B"})) (Just (Type (TokenInfo{offset = 75, value = "A"}))) [AttributeDefinition (Ident (TokenInfo{offset = 83, value = "y"})) (Type (TokenInfo{offset = 87, value = "Int"})) (Just (IntegerLiteral (Integer (TokenInfo{offset = 94, value = 0})))), MethodDefinition (Ident (TokenInfo{offset = 102, value = "g"})) [Formal (Ident (TokenInfo{offset = 104, value = "x"})) (Type (TokenInfo{offset = 108, value = "Int"})), Formal (Ident (TokenInfo{offset = 113, value = "y"})) (Type (TokenInfo{offset = 117, value = "Bool"}))] (Type (TokenInfo{offset = 125, value = "Int"})) (IntegerLiteral (Integer (TokenInfo{offset = 131, value = 0})))]])

testLiteralId :: Ast -> Spec
testLiteralId ast = do
    describe "Parser" $ do
        it "should ast literal" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), Assign, Integer (TokenInfo{offset = 25, value = 0}), SemiColon, Ident (TokenInfo{offset = 32, value = "s"}), Colon, Type (TokenInfo{offset = 36, value = "String"}), Assign, String (TokenInfo{offset = 46, value = "abc"}), SemiColon, Ident (TokenInfo{offset = 57, value = "b"}), Colon, Type (TokenInfo{offset = 61, value = "Bool"}), Assign, Boolean (TokenInfo{offset = 69, value = False}), SemiColon, Ident (TokenInfo{offset = 80, value = "c"}), Colon, Type (TokenInfo{offset = 84, value = "Bool"}), Assign, Ident (TokenInfo{offset = 92, value = "b"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "n"})) (Type (TokenInfo{offset = 18, value = "Int"})) (Just (IntegerLiteral (Integer (TokenInfo{offset = 25, value = 0})))), AttributeDefinition (Ident (TokenInfo{offset = 32, value = "s"})) (Type (TokenInfo{offset = 36, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 46, value = "abc"})))), AttributeDefinition (Ident (TokenInfo{offset = 57, value = "b"})) (Type (TokenInfo{offset = 61, value = "Bool"})) (Just (BoolLiteral (Boolean (TokenInfo{offset = 69, value = False})))), AttributeDefinition (Ident (TokenInfo{offset = 80, value = "c"})) (Type (TokenInfo{offset = 84, value = "Bool"})) (Just (IdentStatement (Ident (TokenInfo{offset = 92, value = "b"}))))]])
testArithmetic :: Ast -> Spec
testArithmetic ast = do
    describe "Parser" $ do
        it "should ast arithmetic" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), Assign, Integer (TokenInfo{offset = 25, value = 1}), Plus, Integer (TokenInfo{offset = 29, value = 2}), Asterisk, LeftParen, Integer (TokenInfo{offset = 34, value = 3}), Plus, Integer (TokenInfo{offset = 38, value = 4}), RightParen, Slash, LeftParen, Integer (TokenInfo{offset = 44, value = 5}), Minus, Tilde, Integer (TokenInfo{offset = 49, value = 6}), RightParen, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "n"})) (Type (TokenInfo{offset = 18, value = "Int"})) (Just (AddStatement (IntegerLiteral (Integer (TokenInfo{offset = 25, value = 1}))) (DivStatement (MulStatement (IntegerLiteral (Integer (TokenInfo{offset = 29, value = 2}))) (AddStatement (IntegerLiteral (Integer (TokenInfo{offset = 34, value = 3}))) (IntegerLiteral (Integer (TokenInfo{offset = 38, value = 4}))))) (SubStatement (IntegerLiteral (Integer (TokenInfo{offset = 44, value = 5}))) (NegationStatement (IntegerLiteral (Integer (TokenInfo{offset = 49, value = 6}))))))))]])

testRelational :: Ast -> Spec
testRelational ast = do
    describe "Parser" $ do
        it "should ast relational" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 27, value = "b"}), Colon, Type (TokenInfo{offset = 31, value = "Bool"}), Assign, Not, Integer (TokenInfo{offset = 43, value = 2}), LessEqual, Ident (TokenInfo{offset = 48, value = "n"}), SemiColon, Ident (TokenInfo{offset = 55, value = "c"}), Colon, Type (TokenInfo{offset = 59, value = "Bool"}), Assign, Integer (TokenInfo{offset = 67, value = 2}), LessThan, Ident (TokenInfo{offset = 71, value = "n"}), Plus, Integer (TokenInfo{offset = 75, value = 1}), Equal, Boolean (TokenInfo{offset = 79, value = False}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "n"})) (Type (TokenInfo{offset = 18, value = "Int"})) Nothing, AttributeDefinition (Ident (TokenInfo{offset = 27, value = "b"})) (Type (TokenInfo{offset = 31, value = "Bool"})) (Just (NotStatement (LessThanOrEqualStatement (IntegerLiteral (Integer (TokenInfo{offset = 43, value = 2}))) (IdentStatement (Ident (TokenInfo{offset = 48, value = "n"})))))), AttributeDefinition (Ident (TokenInfo{offset = 55, value = "c"})) (Type (TokenInfo{offset = 59, value = "Bool"})) (Just (EqualStatement (LessThanStatement (IntegerLiteral (Integer (TokenInfo{offset = 67, value = 2}))) (AddStatement (IdentStatement (Ident (TokenInfo{offset = 71, value = "n"}))) (IntegerLiteral (Integer (TokenInfo{offset = 75, value = 1}))))) (BoolLiteral (Boolean (TokenInfo{offset = 79, value = False})))))]])

testAssignment :: Ast -> Spec
testAssignment ast = do
    describe "Parser" $ do
        it "should ast assignment" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 28, value = "f"}), LeftParen, Ident (TokenInfo{offset = 30, value = "y"}), Colon, Type (TokenInfo{offset = 34, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 41, value = "Int"}), LeftSquirly, Ident (TokenInfo{offset = 55, value = "x"}), Assign, Ident (TokenInfo{offset = 60, value = "y"}), RightSquirly, SemiColon, Ident (TokenInfo{offset = 74, value = "f"}), LeftParen, Ident (TokenInfo{offset = 76, value = "y"}), Colon, Type (TokenInfo{offset = 80, value = "Int"}), Comma, Ident (TokenInfo{offset = 85, value = "z"}), Colon, Type (TokenInfo{offset = 89, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 96, value = "Int"}), LeftSquirly, Ident (TokenInfo{offset = 110, value = "x"}), Assign, Ident (TokenInfo{offset = 115, value = "y"}), Assign, Ident (TokenInfo{offset = 120, value = "z"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "x"})) (Type (TokenInfo{offset = 18, value = "Int"})) Nothing, MethodDefinition (Ident (TokenInfo{offset = 28, value = "f"})) [Formal (Ident (TokenInfo{offset = 30, value = "y"})) (Type (TokenInfo{offset = 34, value = "Int"}))] (Type (TokenInfo{offset = 41, value = "Int"})) (AssignStatement (Ident (TokenInfo{offset = 55, value = "x"})) (IdentStatement (Ident (TokenInfo{offset = 60, value = "y"})))), MethodDefinition (Ident (TokenInfo{offset = 74, value = "f"})) [Formal (Ident (TokenInfo{offset = 76, value = "y"})) (Type (TokenInfo{offset = 80, value = "Int"})), Formal (Ident (TokenInfo{offset = 85, value = "z"})) (Type (TokenInfo{offset = 89, value = "Int"}))] (Type (TokenInfo{offset = 96, value = "Int"})) (AssignStatement (Ident (TokenInfo{offset = 110, value = "x"})) (AssignStatement (Ident (TokenInfo{offset = 115, value = "y"})) (IdentStatement (Ident (TokenInfo{offset = 120, value = "z"})))))]])

testNewIsVoid :: Ast -> Spec
testNewIsVoid ast = do
    describe "Parser" $ do
        it "should ast new isvoid" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 20, value = "Bool"}), LeftSquirly, Not, IsVoid, New, Type (TokenInfo{offset = 50, value = "A"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [] (Type (TokenInfo{offset = 20, value = "Bool"})) (NotStatement (IsVoidStatement (NewStatement (Type (TokenInfo{offset = 50, value = "A"})))))]])

testDispatch :: Ast -> Spec
testDispatch ast = do
    describe "Parser" $ do
        it "should ast dispatch" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Bool"}), LeftSquirly, Ident (TokenInfo{offset = 42, value = "f"}), LeftParen, Ident (TokenInfo{offset = 44, value = "x"}), Plus, Integer (TokenInfo{offset = 48, value = 1}), RightParen, RightSquirly, SemiColon, Ident (TokenInfo{offset = 63, value = "g"}), LeftParen, Ident (TokenInfo{offset = 65, value = "x"}), Colon, Type (TokenInfo{offset = 69, value = "Int"}), Comma, Ident (TokenInfo{offset = 74, value = "y"}), Colon, Type (TokenInfo{offset = 78, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 85, value = "Bool"}), LeftSquirly, Ident (TokenInfo{offset = 100, value = "self"}), Dot, Ident (TokenInfo{offset = 105, value = "g"}), LeftParen, Ident (TokenInfo{offset = 107, value = "x"}), Plus, Integer (TokenInfo{offset = 111, value = 1}), Comma, Ident (TokenInfo{offset = 114, value = "y"}), Plus, Integer (TokenInfo{offset = 118, value = 1}), RightParen, RightSquirly, SemiColon, Ident (TokenInfo{offset = 133, value = "h"}), LeftParen, Ident (TokenInfo{offset = 135, value = "x"}), Colon, Type (TokenInfo{offset = 139, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 146, value = "A"}), LeftSquirly, New, Type (TokenInfo{offset = 162, value = "A"}), At, Type (TokenInfo{offset = 164, value = "A"}), Dot, Ident (TokenInfo{offset = 166, value = "h"}), LeftParen, Ident (TokenInfo{offset = 168, value = "x"}), Plus, Integer (TokenInfo{offset = 172, value = 1}), RightParen, Dot, Ident (TokenInfo{offset = 175, value = "h"}), LeftParen, Ident (TokenInfo{offset = 177, value = "x"}), Plus, Integer (TokenInfo{offset = 181, value = 2}), RightParen, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Int"}))] (Type (TokenInfo{offset = 27, value = "Bool"})) (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 42, value = "f"})) [AddStatement (IdentStatement (Ident (TokenInfo{offset = 44, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 48, value = 1})))]), MethodDefinition (Ident (TokenInfo{offset = 63, value = "g"})) [Formal (Ident (TokenInfo{offset = 65, value = "x"})) (Type (TokenInfo{offset = 69, value = "Int"})), Formal (Ident (TokenInfo{offset = 74, value = "y"})) (Type (TokenInfo{offset = 78, value = "Int"}))] (Type (TokenInfo{offset = 85, value = "Bool"})) (MethodCall (Just (IdentStatement (Ident (TokenInfo{offset = 100, value = "self"})))) Nothing (Ident (TokenInfo{offset = 105, value = "g"})) [AddStatement (IdentStatement (Ident (TokenInfo{offset = 107, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 111, value = 1}))), AddStatement (IdentStatement (Ident (TokenInfo{offset = 114, value = "y"}))) (IntegerLiteral (Integer (TokenInfo{offset = 118, value = 1})))]), MethodDefinition (Ident (TokenInfo{offset = 133, value = "h"})) [Formal (Ident (TokenInfo{offset = 135, value = "x"})) (Type (TokenInfo{offset = 139, value = "Int"}))] (Type (TokenInfo{offset = 146, value = "A"})) (MethodCall (Just (MethodCall (Just (NewStatement (Type (TokenInfo{offset = 162, value = "A"})))) (Just (Type (TokenInfo{offset = 164, value = "A"}))) (Ident (TokenInfo{offset = 166, value = "h"})) [AddStatement (IdentStatement (Ident (TokenInfo{offset = 168, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 172, value = 1})))])) Nothing (Ident (TokenInfo{offset = 175, value = "h"})) [AddStatement (IdentStatement (Ident (TokenInfo{offset = 177, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 181, value = 2})))])]])

testIf :: Ast -> Spec
testIf ast = do
    describe "Parser" $ do
        it "should ast if" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Int"}), LeftSquirly, If, Ident (TokenInfo{offset = 44, value = "x"}), LessEqual, Integer (TokenInfo{offset = 49, value = 5}), Then, Ident (TokenInfo{offset = 56, value = "x"}), Else, Ident (TokenInfo{offset = 63, value = "x"}), Plus, Integer (TokenInfo{offset = 67, value = 1}), Fi, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Int"}))] (Type (TokenInfo{offset = 27, value = "Int"})) (IfStatement (LessThanOrEqualStatement (IdentStatement (Ident (TokenInfo{offset = 44, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 49, value = 5})))) (IdentStatement (Ident (TokenInfo{offset = 56, value = "x"}))) (AddStatement (IdentStatement (Ident (TokenInfo{offset = 63, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 67, value = 1})))))]])

testWhile :: Ast -> Spec
testWhile ast = do
    describe "Parser" $ do
        it "should ast while" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Object"}), LeftSquirly, While, Integer (TokenInfo{offset = 50, value = 0}), LessThan, Ident (TokenInfo{offset = 54, value = "x"}), Loop, Ident (TokenInfo{offset = 73, value = "x"}), Assign, Ident (TokenInfo{offset = 78, value = "x"}), Minus, Integer (TokenInfo{offset = 82, value = 1}), Pool, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Int"}))] (Type (TokenInfo{offset = 27, value = "Object"})) (WhileStatement (LessThanStatement (IntegerLiteral (Integer (TokenInfo{offset = 50, value = 0}))) (IdentStatement (Ident (TokenInfo{offset = 54, value = "x"})))) (AssignStatement (Ident (TokenInfo{offset = 73, value = "x"})) (SubStatement (IdentStatement (Ident (TokenInfo{offset = 78, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 82, value = 1}))))))]])

testLet :: Ast -> Spec
testLet ast = do
    describe "Parser" $ do
        it "should ast let" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Int"}), LeftSquirly, Let, Ident (TokenInfo{offset = 45, value = "x"}), Colon, Type (TokenInfo{offset = 49, value = "Int"}), Assign, Ident (TokenInfo{offset = 56, value = "x"}), Plus, Integer (TokenInfo{offset = 60, value = 1}), Comma, Ident (TokenInfo{offset = 75, value = "y"}), Colon, Type (TokenInfo{offset = 79, value = "Int"}), Assign, Ident (TokenInfo{offset = 86, value = "x"}), Plus, Integer (TokenInfo{offset = 90, value = 1}), In, Ident (TokenInfo{offset = 115, value = "x"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Int"}))] (Type (TokenInfo{offset = 27, value = "Int"})) (LetStatement [VariableDefinition (Ident (TokenInfo{offset = 45, value = "x"})) (Type (TokenInfo{offset = 49, value = "Int"})) (Just (AddStatement (IdentStatement (Ident (TokenInfo{offset = 56, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 60, value = 1}))))), VariableDefinition (Ident (TokenInfo{offset = 75, value = "y"})) (Type (TokenInfo{offset = 79, value = "Int"})) (Just (AddStatement (IdentStatement (Ident (TokenInfo{offset = 86, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 90, value = 1})))))] (IdentStatement (Ident (TokenInfo{offset = 115, value = "x"}))))]])

testCase :: Ast -> Spec
testCase ast = do
    describe "Parser" $ do
        it "should ast case" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Object"}), RightParen, Colon, Type (TokenInfo{offset = 30, value = "String"}), LeftSquirly, Case, Ident (TokenInfo{offset = 52, value = "x"}), Of, Ident (TokenInfo{offset = 69, value = "s"}), Colon, Type (TokenInfo{offset = 73, value = "String"}), Results, String (TokenInfo{offset = 83, value = "String"}), SemiColon, Ident (TokenInfo{offset = 105, value = "i"}), Colon, Type (TokenInfo{offset = 109, value = "Int"}), Results, String (TokenInfo{offset = 119, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 138, value = "o"}), Colon, Type (TokenInfo{offset = 142, value = "Object"}), Results, String (TokenInfo{offset = 152, value = "Oops"}), SemiColon, Esac, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Object"}))] (Type (TokenInfo{offset = 30, value = "String"})) (CaseStatement (IdentStatement (Ident (TokenInfo{offset = 52, value = "x"}))) [CaseOfDefinition (Ident (TokenInfo{offset = 69, value = "s"})) (Type (TokenInfo{offset = 73, value = "String"})) (StringLiteral (String (TokenInfo{offset = 83, value = "String"}))), CaseOfDefinition (Ident (TokenInfo{offset = 105, value = "i"})) (Type (TokenInfo{offset = 109, value = "Int"})) (StringLiteral (String (TokenInfo{offset = 119, value = "Int"}))), CaseOfDefinition (Ident (TokenInfo{offset = 138, value = "o"})) (Type (TokenInfo{offset = 142, value = "Object"})) (StringLiteral (String (TokenInfo{offset = 152, value = "Oops"})))])]])

testBlock :: Ast -> Spec
testBlock ast = do
    describe "Parser" $ do
        it "should ast block" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "String"}), LeftSquirly, LeftSquirly, Ident (TokenInfo{offset = 58, value = "x"}), Assign, Ident (TokenInfo{offset = 63, value = "x"}), Plus, Integer (TokenInfo{offset = 67, value = 1}), SemiColon, String (TokenInfo{offset = 82, value = "Done!"}), SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [MethodDefinition (Ident (TokenInfo{offset = 14, value = "f"})) [Formal (Ident (TokenInfo{offset = 16, value = "x"})) (Type (TokenInfo{offset = 20, value = "Int"}))] (Type (TokenInfo{offset = 27, value = "String"})) (BlockStatement [AssignStatement (Ident (TokenInfo{offset = 58, value = "x"})) (AddStatement (IdentStatement (Ident (TokenInfo{offset = 63, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 67, value = 1})))), StringLiteral (String (TokenInfo{offset = 82, value = "Done!"}))])]])

testStringSpecialChars :: Ast -> Spec
testStringSpecialChars ast = do
    describe "Parser" $ do
        it "should ast string with special chars" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "s1"}), Colon, Type (TokenInfo{offset = 19, value = "String"}), Assign, String (TokenInfo{offset = 29, value = "ab\tcd"}), SemiColon, Ident (TokenInfo{offset = 43, value = "s2"}), Colon, Type (TokenInfo{offset = 48, value = "String"}), Assign, String (TokenInfo{offset = 58, value = "ab\ncd"}), SemiColon, Ident (TokenInfo{offset = 72, value = "s3"}), Colon, Type (TokenInfo{offset = 77, value = "String"}), Assign, String (TokenInfo{offset = 87, value = "ab\ncd"}), SemiColon, Ident (TokenInfo{offset = 101, value = "s4"}), Colon, Type (TokenInfo{offset = 106, value = "String"}), Assign, String (TokenInfo{offset = 116, value = "ab\\cd"}), SemiColon, Ident (TokenInfo{offset = 130, value = "s5"}), Colon, Type (TokenInfo{offset = 135, value = "String"}), Assign, String (TokenInfo{offset = 145, value = "abzcd"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 6, value = "A"})) Nothing [AttributeDefinition (Ident (TokenInfo{offset = 14, value = "s1"})) (Type (TokenInfo{offset = 19, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 29, value = "ab\tcd"})))), AttributeDefinition (Ident (TokenInfo{offset = 43, value = "s2"})) (Type (TokenInfo{offset = 48, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 58, value = "ab\ncd"})))), AttributeDefinition (Ident (TokenInfo{offset = 72, value = "s3"})) (Type (TokenInfo{offset = 77, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 87, value = "ab\ncd"})))), AttributeDefinition (Ident (TokenInfo{offset = 101, value = "s4"})) (Type (TokenInfo{offset = 106, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 116, value = "ab\\cd"})))), AttributeDefinition (Ident (TokenInfo{offset = 130, value = "s5"})) (Type (TokenInfo{offset = 135, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 145, value = "abzcd"}))))]])

testBig :: Ast -> Spec
testBig ast = do
    describe "Parser" $ do
        it "should ast big text" $
            do
                ast [Class, Type (TokenInfo{offset = 190, value = "List"}), Inherits, Type (TokenInfo{offset = 204, value = "IO"}), LeftSquirly, Ident (TokenInfo{offset = 213, value = "elem"}), Colon, Type (TokenInfo{offset = 220, value = "Object"}), SemiColon, Ident (TokenInfo{offset = 232, value = "next"}), Colon, Type (TokenInfo{offset = 239, value = "List"}), SemiColon, Ident (TokenInfo{offset = 250, value = "init"}), LeftParen, Ident (TokenInfo{offset = 255, value = "e"}), Colon, Type (TokenInfo{offset = 259, value = "Object"}), Comma, Ident (TokenInfo{offset = 267, value = "n"}), Colon, Type (TokenInfo{offset = 271, value = "List"}), RightParen, Colon, Type (TokenInfo{offset = 279, value = "List"}), LeftSquirly, LeftSquirly, Ident (TokenInfo{offset = 308, value = "elem"}), Assign, Ident (TokenInfo{offset = 316, value = "e"}), SemiColon, Ident (TokenInfo{offset = 331, value = "next"}), Assign, Ident (TokenInfo{offset = 339, value = "n"}), SemiColon, Ident (TokenInfo{offset = 354, value = "self"}), SemiColon, RightSquirly, RightSquirly, SemiColon, Ident (TokenInfo{offset = 382, value = "print"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 392, value = "IO"}), LeftSquirly, Let, Ident (TokenInfo{offset = 409, value = "str"}), Colon, Type (TokenInfo{offset = 415, value = "String"}), Assign, Case, Ident (TokenInfo{offset = 672, value = "elem"}), Of, Ident (TokenInfo{offset = 700, value = "s"}), Colon, Type (TokenInfo{offset = 704, value = "String"}), Results, Ident (TokenInfo{offset = 714, value = "s"}), SemiColon, Ident (TokenInfo{offset = 737, value = "n"}), Colon, Type (TokenInfo{offset = 741, value = "Int"}), Results, New, Type (TokenInfo{offset = 752, value = "A2I"}), Dot, Ident (TokenInfo{offset = 756, value = "i2a"}), LeftParen, Ident (TokenInfo{offset = 760, value = "n"}), RightParen, SemiColon, Ident (TokenInfo{offset = 814, value = "o"}), Colon, Type (TokenInfo{offset = 818, value = "Object"}), Results, LeftSquirly, Ident (TokenInfo{offset = 830, value = "abort"}), LeftParen, RightParen, SemiColon, String (TokenInfo{offset = 839, value = ""}), SemiColon, RightSquirly, SemiColon, Esac, In, LeftSquirly, Ident (TokenInfo{offset = 908, value = "out_string"}), LeftParen, Ident (TokenInfo{offset = 919, value = "str"}), Dot, Ident (TokenInfo{offset = 923, value = "concat"}), LeftParen, String (TokenInfo{offset = 930, value = " "}), RightParen, RightParen, SemiColon, If, LeftParen, IsVoid, Ident (TokenInfo{offset = 964, value = "next"}), RightParen, Then, Ident (TokenInfo{offset = 975, value = "out_string"}), LeftParen, String (TokenInfo{offset = 986, value = "\n"}), RightParen, Else, Ident (TokenInfo{offset = 997, value = "next"}), Dot, Ident (TokenInfo{offset = 1002, value = "print"}), LeftParen, RightParen, Fi, SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 1045, value = "Main"}), Inherits, Type (TokenInfo{offset = 1059, value = "IO"}), LeftSquirly, Ident (TokenInfo{offset = 1068, value = "main"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 1077, value = "Object"}), LeftSquirly, LeftSquirly, Let, Ident (TokenInfo{offset = 1112, value = "x"}), Colon, Type (TokenInfo{offset = 1116, value = "Int"}), Assign, Integer (TokenInfo{offset = 1123, value = 0}), Comma, Ident (TokenInfo{offset = 1142, value = "y"}), Colon, Type (TokenInfo{offset = 1146, value = "String"}), Assign, String (TokenInfo{offset = 1156, value = "!"}), Comma, Ident (TokenInfo{offset = 1177, value = "z"}), Colon, Type (TokenInfo{offset = 1181, value = "Int"}), Assign, Ident (TokenInfo{offset = 1188, value = "x"}), Plus, Integer (TokenInfo{offset = 1192, value = 2}), Comma, Ident (TokenInfo{offset = 1211, value = "empty"}), Colon, Type (TokenInfo{offset = 1219, value = "List"}), Comma, Ident (TokenInfo{offset = 1275, value = "list"}), Colon, Type (TokenInfo{offset = 1282, value = "List"}), Assign, New, Type (TokenInfo{offset = 1314, value = "List"}), Dot, Ident (TokenInfo{offset = 1319, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1324, value = "x"}), Comma, New, Type (TokenInfo{offset = 1355, value = "List"}), Dot, Ident (TokenInfo{offset = 1360, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1365, value = "y"}), Comma, New, Type (TokenInfo{offset = 1400, value = "List"}), Dot, Ident (TokenInfo{offset = 1405, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1410, value = "z"}), Comma, Ident (TokenInfo{offset = 1413, value = "empty"}), RightParen, RightParen, RightParen, In, Ident (TokenInfo{offset = 1453, value = "list"}), Dot, Ident (TokenInfo{offset = 1458, value = "print"}), LeftParen, RightParen, SemiColon, Let, Ident (TokenInfo{offset = 1561, value = "n"}), Colon, Type (TokenInfo{offset = 1565, value = "Int"}), Assign, Ident (TokenInfo{offset = 1572, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1583, value = "Calcul\259m factorial pentru: "}), RightParen, Dot, Ident (TokenInfo{offset = 1614, value = "in_int"}), LeftParen, RightParen, In, LeftSquirly, Ident (TokenInfo{offset = 1676, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1687, value = "Factorial recursiv: "}), RightParen, Dot, Ident (TokenInfo{offset = 1711, value = "out_int"}), LeftParen, Ident (TokenInfo{offset = 1719, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 1728, value = "n"}), RightParen, RightParen, Dot, Ident (TokenInfo{offset = 1757, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1768, value = "\n"}), RightParen, SemiColon, Ident (TokenInfo{offset = 1795, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1806, value = "Factorial iterativ: "}), RightParen, Dot, Ident (TokenInfo{offset = 1830, value = "out_int"}), LeftParen, Ident (TokenInfo{offset = 1838, value = "fact_iter"}), LeftParen, Ident (TokenInfo{offset = 1848, value = "n"}), RightParen, RightParen, Dot, Ident (TokenInfo{offset = 1877, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1888, value = "\n"}), RightParen, SemiColon, RightSquirly, SemiColon, RightSquirly, RightSquirly, SemiColon, Ident (TokenInfo{offset = 1974, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 1983, value = "n"}), Colon, Type (TokenInfo{offset = 1987, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 1994, value = "Int"}), LeftSquirly, If, Ident (TokenInfo{offset = 2011, value = "n"}), Equal, Integer (TokenInfo{offset = 2015, value = 0}), Then, Integer (TokenInfo{offset = 2022, value = 1}), Else, Ident (TokenInfo{offset = 2029, value = "n"}), Asterisk, Ident (TokenInfo{offset = 2033, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 2042, value = "n"}), Minus, Integer (TokenInfo{offset = 2046, value = 1}), RightParen, Fi, RightSquirly, SemiColon, Ident (TokenInfo{offset = 2102, value = "fact_iter"}), LeftParen, Ident (TokenInfo{offset = 2112, value = "n"}), Colon, Type (TokenInfo{offset = 2116, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 2123, value = "Int"}), LeftSquirly, Let, Ident (TokenInfo{offset = 2141, value = "res"}), Colon, Type (TokenInfo{offset = 2147, value = "Int"}), Assign, Integer (TokenInfo{offset = 2154, value = 1}), In, LeftSquirly, While, LeftParen, Not, LeftParen, Ident (TokenInfo{offset = 2329, value = "n"}), Equal, Integer (TokenInfo{offset = 2333, value = 0}), RightParen, RightParen, Loop, LeftSquirly, Ident (TokenInfo{offset = 2388, value = "res"}), Assign, Ident (TokenInfo{offset = 2395, value = "res"}), Asterisk, Ident (TokenInfo{offset = 2401, value = "n"}), SemiColon, Ident (TokenInfo{offset = 2428, value = "n"}), Assign, Ident (TokenInfo{offset = 2433, value = "n"}), Minus, Integer (TokenInfo{offset = 2437, value = 1}), SemiColon, RightSquirly, Pool, SemiColon, Ident (TokenInfo{offset = 2500, value = "res"}), SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (Type (TokenInfo{offset = 190, value = "List"})) (Just (Type (TokenInfo{offset = 204, value = "IO"}))) [AttributeDefinition (Ident (TokenInfo{offset = 213, value = "elem"})) (Type (TokenInfo{offset = 220, value = "Object"})) Nothing, AttributeDefinition (Ident (TokenInfo{offset = 232, value = "next"})) (Type (TokenInfo{offset = 239, value = "List"})) Nothing, MethodDefinition (Ident (TokenInfo{offset = 250, value = "init"})) [Formal (Ident (TokenInfo{offset = 255, value = "e"})) (Type (TokenInfo{offset = 259, value = "Object"})), Formal (Ident (TokenInfo{offset = 267, value = "n"})) (Type (TokenInfo{offset = 271, value = "List"}))] (Type (TokenInfo{offset = 279, value = "List"})) (BlockStatement [AssignStatement (Ident (TokenInfo{offset = 308, value = "elem"})) (IdentStatement (Ident (TokenInfo{offset = 316, value = "e"}))), AssignStatement (Ident (TokenInfo{offset = 331, value = "next"})) (IdentStatement (Ident (TokenInfo{offset = 339, value = "n"}))), IdentStatement (Ident (TokenInfo{offset = 354, value = "self"}))]), MethodDefinition (Ident (TokenInfo{offset = 382, value = "print"})) [] (Type (TokenInfo{offset = 392, value = "IO"})) (LetStatement [VariableDefinition (Ident (TokenInfo{offset = 409, value = "str"})) (Type (TokenInfo{offset = 415, value = "String"})) (Just (CaseStatement (IdentStatement (Ident (TokenInfo{offset = 672, value = "elem"}))) [CaseOfDefinition (Ident (TokenInfo{offset = 700, value = "s"})) (Type (TokenInfo{offset = 704, value = "String"})) (IdentStatement (Ident (TokenInfo{offset = 714, value = "s"}))), CaseOfDefinition (Ident (TokenInfo{offset = 737, value = "n"})) (Type (TokenInfo{offset = 741, value = "Int"})) (MethodCall (Just (NewStatement (Type (TokenInfo{offset = 752, value = "A2I"})))) Nothing (Ident (TokenInfo{offset = 756, value = "i2a"})) [IdentStatement (Ident (TokenInfo{offset = 760, value = "n"}))]), CaseOfDefinition (Ident (TokenInfo{offset = 814, value = "o"})) (Type (TokenInfo{offset = 818, value = "Object"})) (BlockStatement [MethodCall Nothing Nothing (Ident (TokenInfo{offset = 830, value = "abort"})) [], StringLiteral (String (TokenInfo{offset = 839, value = ""}))])]))] (BlockStatement [MethodCall Nothing Nothing (Ident (TokenInfo{offset = 908, value = "out_string"})) [MethodCall (Just (IdentStatement (Ident (TokenInfo{offset = 919, value = "str"})))) Nothing (Ident (TokenInfo{offset = 923, value = "concat"})) [StringLiteral (String (TokenInfo{offset = 930, value = " "}))]], IfStatement (IsVoidStatement (IdentStatement (Ident (TokenInfo{offset = 964, value = "next"})))) (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 975, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 986, value = "\n"}))]) (MethodCall (Just (IdentStatement (Ident (TokenInfo{offset = 997, value = "next"})))) Nothing (Ident (TokenInfo{offset = 1002, value = "print"})) [])]))], ClassDefinition (Type (TokenInfo{offset = 1045, value = "Main"})) (Just (Type (TokenInfo{offset = 1059, value = "IO"}))) [MethodDefinition (Ident (TokenInfo{offset = 1068, value = "main"})) [] (Type (TokenInfo{offset = 1077, value = "Object"})) (BlockStatement [LetStatement [VariableDefinition (Ident (TokenInfo{offset = 1112, value = "x"})) (Type (TokenInfo{offset = 1116, value = "Int"})) (Just (IntegerLiteral (Integer (TokenInfo{offset = 1123, value = 0})))), VariableDefinition (Ident (TokenInfo{offset = 1142, value = "y"})) (Type (TokenInfo{offset = 1146, value = "String"})) (Just (StringLiteral (String (TokenInfo{offset = 1156, value = "!"})))), VariableDefinition (Ident (TokenInfo{offset = 1177, value = "z"})) (Type (TokenInfo{offset = 1181, value = "Int"})) (Just (AddStatement (IdentStatement (Ident (TokenInfo{offset = 1188, value = "x"}))) (IntegerLiteral (Integer (TokenInfo{offset = 1192, value = 2}))))), VariableDefinition (Ident (TokenInfo{offset = 1211, value = "empty"})) (Type (TokenInfo{offset = 1219, value = "List"})) Nothing, VariableDefinition (Ident (TokenInfo{offset = 1275, value = "list"})) (Type (TokenInfo{offset = 1282, value = "List"})) (Just (MethodCall (Just (NewStatement (Type (TokenInfo{offset = 1314, value = "List"})))) Nothing (Ident (TokenInfo{offset = 1319, value = "init"})) [IdentStatement (Ident (TokenInfo{offset = 1324, value = "x"})), MethodCall (Just (NewStatement (Type (TokenInfo{offset = 1355, value = "List"})))) Nothing (Ident (TokenInfo{offset = 1360, value = "init"})) [IdentStatement (Ident (TokenInfo{offset = 1365, value = "y"})), MethodCall (Just (NewStatement (Type (TokenInfo{offset = 1400, value = "List"})))) Nothing (Ident (TokenInfo{offset = 1405, value = "init"})) [IdentStatement (Ident (TokenInfo{offset = 1410, value = "z"})), IdentStatement (Ident (TokenInfo{offset = 1413, value = "empty"}))]]]))] (MethodCall (Just (IdentStatement (Ident (TokenInfo{offset = 1453, value = "list"})))) Nothing (Ident (TokenInfo{offset = 1458, value = "print"})) []), LetStatement [VariableDefinition (Ident (TokenInfo{offset = 1561, value = "n"})) (Type (TokenInfo{offset = 1565, value = "Int"})) (Just (MethodCall (Just (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 1572, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 1583, value = "Calcul\259m factorial pentru: "}))])) Nothing (Ident (TokenInfo{offset = 1614, value = "in_int"})) []))] (BlockStatement [MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 1676, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 1687, value = "Factorial recursiv: "}))])) Nothing (Ident (TokenInfo{offset = 1711, value = "out_int"})) [MethodCall Nothing Nothing (Ident (TokenInfo{offset = 1719, value = "fact_rec"})) [IdentStatement (Ident (TokenInfo{offset = 1728, value = "n"}))]])) Nothing (Ident (TokenInfo{offset = 1757, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 1768, value = "\n"}))], MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 1795, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 1806, value = "Factorial iterativ: "}))])) Nothing (Ident (TokenInfo{offset = 1830, value = "out_int"})) [MethodCall Nothing Nothing (Ident (TokenInfo{offset = 1838, value = "fact_iter"})) [IdentStatement (Ident (TokenInfo{offset = 1848, value = "n"}))]])) Nothing (Ident (TokenInfo{offset = 1877, value = "out_string"})) [StringLiteral (String (TokenInfo{offset = 1888, value = "\n"}))]])]), MethodDefinition (Ident (TokenInfo{offset = 1974, value = "fact_rec"})) [Formal (Ident (TokenInfo{offset = 1983, value = "n"})) (Type (TokenInfo{offset = 1987, value = "Int"}))] (Type (TokenInfo{offset = 1994, value = "Int"})) (IfStatement (EqualStatement (IdentStatement (Ident (TokenInfo{offset = 2011, value = "n"}))) (IntegerLiteral (Integer (TokenInfo{offset = 2015, value = 0})))) (IntegerLiteral (Integer (TokenInfo{offset = 2022, value = 1}))) (MulStatement (IdentStatement (Ident (TokenInfo{offset = 2029, value = "n"}))) (MethodCall Nothing Nothing (Ident (TokenInfo{offset = 2033, value = "fact_rec"})) [SubStatement (IdentStatement (Ident (TokenInfo{offset = 2042, value = "n"}))) (IntegerLiteral (Integer (TokenInfo{offset = 2046, value = 1})))]))), MethodDefinition (Ident (TokenInfo{offset = 2102, value = "fact_iter"})) [Formal (Ident (TokenInfo{offset = 2112, value = "n"})) (Type (TokenInfo{offset = 2116, value = "Int"}))] (Type (TokenInfo{offset = 2123, value = "Int"})) (LetStatement [VariableDefinition (Ident (TokenInfo{offset = 2141, value = "res"})) (Type (TokenInfo{offset = 2147, value = "Int"})) (Just (IntegerLiteral (Integer (TokenInfo{offset = 2154, value = 1}))))] (BlockStatement [WhileStatement (NotStatement (EqualStatement (IdentStatement (Ident (TokenInfo{offset = 2329, value = "n"}))) (IntegerLiteral (Integer (TokenInfo{offset = 2333, value = 0}))))) (BlockStatement [AssignStatement (Ident (TokenInfo{offset = 2388, value = "res"})) (MulStatement (IdentStatement (Ident (TokenInfo{offset = 2395, value = "res"}))) (IdentStatement (Ident (TokenInfo{offset = 2401, value = "n"})))), AssignStatement (Ident (TokenInfo{offset = 2428, value = "n"})) (SubStatement (IdentStatement (Ident (TokenInfo{offset = 2433, value = "n"}))) (IntegerLiteral (Integer (TokenInfo{offset = 2437, value = 1}))))]), IdentStatement (Ident (TokenInfo{offset = 2500, value = "res"}))]))]])
