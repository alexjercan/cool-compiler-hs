module ParserTest (parserTests) where

import AST
import Test.Hspec (Spec, describe, it, shouldBe)
import Token

parserTests :: Ast -> Spec
parserTests ast = do
    testClass ast
    testAttributeNoInit ast
    testAttributeInit ast
    testMethod ast
    testLiteralId ast
    testArithmetic ast
    testRelational ast
    testAssignment ast
    testNewIsVoid ast
    testDispatch ast
    testIf ast
    testWhile ast
    testLet ast
    testCase ast
    testBlock ast
    testStringSpecialChars ast
    testBig ast

testClass :: Ast -> Spec
testClass ast = do
    describe "Parser" $ do
        it "should ast class" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 19, value = "B"}), Inherits, Type (TokenInfo{offset = 30, value = "A"}), LeftSquirly, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [], ClassDefinition (TokenInfo{offset = 19, value = "B"}) (Just (TokenInfo{offset = 30, value = "A"})) []])

testAttributeNoInit :: Ast -> Spec
testAttributeNoInit ast = do
    describe "Parser" $ do
        it "should ast attribute no init" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 39, value = "B"}), Inherits, Type (TokenInfo{offset = 50, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 58, value = "y"}), Colon, Type (TokenInfo{offset = 62, value = "Int"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "x"}) (TokenInfo{offset = 18, value = "SELF_TYPE"}) Nothing], ClassDefinition (TokenInfo{offset = 39, value = "B"}) (Just (TokenInfo{offset = 50, value = "A"})) [AttributeDefinition (TokenInfo{offset = 58, value = "y"}) (TokenInfo{offset = 62, value = "Int"}) Nothing]])

testAttributeInit :: Ast -> Spec
testAttributeInit ast = do
    describe "Parser" $ do
        it "should ast attribute init" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 39, value = "B"}), Inherits, Type (TokenInfo{offset = 50, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 58, value = "y"}), Colon, Type (TokenInfo{offset = 62, value = "Int"}), Assign, Integer (TokenInfo{offset = 69, value = 0}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "x"}) (TokenInfo{offset = 18, value = "SELF_TYPE"}) Nothing], ClassDefinition (TokenInfo{offset = 39, value = "B"}) (Just (TokenInfo{offset = 50, value = "A"})) [AttributeDefinition (TokenInfo{offset = 58, value = "y"}) (TokenInfo{offset = 62, value = "Int"}) (Just (IntegerLiteral (TokenInfo{offset = 69, value = 0})))]])

testMethod :: Ast -> Spec
testMethod ast = do
    describe "Parser" $ do
        it "should ast method" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "SELF_TYPE"}), SemiColon, Ident (TokenInfo{offset = 34, value = "f"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 40, value = "Object"}), LeftSquirly, Integer (TokenInfo{offset = 49, value = 0}), RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 64, value = "B"}), Inherits, Type (TokenInfo{offset = 75, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 83, value = "y"}), Colon, Type (TokenInfo{offset = 87, value = "Int"}), Assign, Integer (TokenInfo{offset = 94, value = 0}), SemiColon, Ident (TokenInfo{offset = 102, value = "g"}), LeftParen, Ident (TokenInfo{offset = 104, value = "x"}), Colon, Type (TokenInfo{offset = 108, value = "Int"}), Comma, Ident (TokenInfo{offset = 113, value = "y"}), Colon, Type (TokenInfo{offset = 117, value = "Bool"}), RightParen, Colon, Type (TokenInfo{offset = 125, value = "Int"}), LeftSquirly, Integer (TokenInfo{offset = 131, value = 0}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "x"}) (TokenInfo{offset = 18, value = "SELF_TYPE"}) Nothing, MethodDefinition (TokenInfo{offset = 34, value = "f"}) [] (TokenInfo{offset = 40, value = "Object"}) (IntegerLiteral (TokenInfo{offset = 49, value = 0}))], ClassDefinition (TokenInfo{offset = 64, value = "B"}) (Just (TokenInfo{offset = 75, value = "A"})) [AttributeDefinition (TokenInfo{offset = 83, value = "y"}) (TokenInfo{offset = 87, value = "Int"}) (Just (IntegerLiteral (TokenInfo{offset = 94, value = 0}))), MethodDefinition (TokenInfo{offset = 102, value = "g"}) [Formal (TokenInfo{offset = 104, value = "x"}) (TokenInfo{offset = 108, value = "Int"}), Formal (TokenInfo{offset = 113, value = "y"}) (TokenInfo{offset = 117, value = "Bool"})] (TokenInfo{offset = 125, value = "Int"}) (IntegerLiteral (TokenInfo{offset = 131, value = 0}))]])

testLiteralId :: Ast -> Spec
testLiteralId ast = do
    describe "Parser" $ do
        it "should ast literal" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), Assign, Integer (TokenInfo{offset = 25, value = 0}), SemiColon, Ident (TokenInfo{offset = 32, value = "s"}), Colon, Type (TokenInfo{offset = 36, value = "String"}), Assign, String (TokenInfo{offset = 46, value = "abc"}), SemiColon, Ident (TokenInfo{offset = 57, value = "b"}), Colon, Type (TokenInfo{offset = 61, value = "Bool"}), Assign, Boolean (TokenInfo{offset = 69, value = False}), SemiColon, Ident (TokenInfo{offset = 80, value = "c"}), Colon, Type (TokenInfo{offset = 84, value = "Bool"}), Assign, Ident (TokenInfo{offset = 92, value = "b"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "n"}) (TokenInfo{offset = 18, value = "Int"}) (Just (IntegerLiteral (TokenInfo{offset = 25, value = 0}))), AttributeDefinition (TokenInfo{offset = 32, value = "s"}) (TokenInfo{offset = 36, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 46, value = "abc"}))), AttributeDefinition (TokenInfo{offset = 57, value = "b"}) (TokenInfo{offset = 61, value = "Bool"}) (Just (BoolLiteral (TokenInfo{offset = 69, value = False}))), AttributeDefinition (TokenInfo{offset = 80, value = "c"}) (TokenInfo{offset = 84, value = "Bool"}) (Just (IdentStatement (TokenInfo{offset = 92, value = "b"})))]])

testArithmetic :: Ast -> Spec
testArithmetic ast = do
    describe "Parser" $ do
        it "should ast arithmetic" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), Assign, Integer (TokenInfo{offset = 25, value = 1}), Plus, Integer (TokenInfo{offset = 29, value = 2}), Asterisk, LeftParen, Integer (TokenInfo{offset = 34, value = 3}), Plus, Integer (TokenInfo{offset = 38, value = 4}), RightParen, Slash, LeftParen, Integer (TokenInfo{offset = 44, value = 5}), Minus, Tilde, Integer (TokenInfo{offset = 49, value = 6}), RightParen, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "n"}) (TokenInfo{offset = 18, value = "Int"}) (Just (AddStatement (IntegerLiteral (TokenInfo{offset = 25, value = 1})) (DivStatement (MulStatement (IntegerLiteral (TokenInfo{offset = 29, value = 2})) (AddStatement (IntegerLiteral (TokenInfo{offset = 34, value = 3})) (IntegerLiteral (TokenInfo{offset = 38, value = 4})))) (SubStatement (IntegerLiteral (TokenInfo{offset = 44, value = 5})) (NegationStatement (IntegerLiteral (TokenInfo{offset = 49, value = 6})))))))]])

testRelational :: Ast -> Spec
testRelational ast = do
    describe "Parser" $ do
        it "should ast relational" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "n"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 27, value = "b"}), Colon, Type (TokenInfo{offset = 31, value = "Bool"}), Assign, Not, Integer (TokenInfo{offset = 43, value = 2}), LessEqual, Ident (TokenInfo{offset = 48, value = "n"}), SemiColon, Ident (TokenInfo{offset = 55, value = "c"}), Colon, Type (TokenInfo{offset = 59, value = "Bool"}), Assign, Integer (TokenInfo{offset = 67, value = 2}), LessThan, Ident (TokenInfo{offset = 71, value = "n"}), Plus, Integer (TokenInfo{offset = 75, value = 1}), Equal, Boolean (TokenInfo{offset = 79, value = False}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "n"}) (TokenInfo{offset = 18, value = "Int"}) Nothing, AttributeDefinition (TokenInfo{offset = 27, value = "b"}) (TokenInfo{offset = 31, value = "Bool"}) (Just (NotStatement (LessThanOrEqualStatement (IntegerLiteral (TokenInfo{offset = 43, value = 2})) (IdentStatement (TokenInfo{offset = 48, value = "n"}))))), AttributeDefinition (TokenInfo{offset = 55, value = "c"}) (TokenInfo{offset = 59, value = "Bool"}) (Just (EqualStatement (LessThanStatement (IntegerLiteral (TokenInfo{offset = 67, value = 2})) (AddStatement (IdentStatement (TokenInfo{offset = 71, value = "n"})) (IntegerLiteral (TokenInfo{offset = 75, value = 1})))) (BoolLiteral (TokenInfo{offset = 79, value = False}))))]])

testAssignment :: Ast -> Spec
testAssignment ast = do
    describe "Parser" $ do
        it "should ast assignment" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "x"}), Colon, Type (TokenInfo{offset = 18, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 28, value = "f"}), LeftParen, Ident (TokenInfo{offset = 30, value = "y"}), Colon, Type (TokenInfo{offset = 34, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 41, value = "Int"}), LeftSquirly, Ident (TokenInfo{offset = 55, value = "x"}), Assign, Ident (TokenInfo{offset = 60, value = "y"}), RightSquirly, SemiColon, Ident (TokenInfo{offset = 74, value = "f"}), LeftParen, Ident (TokenInfo{offset = 76, value = "y"}), Colon, Type (TokenInfo{offset = 80, value = "Int"}), Comma, Ident (TokenInfo{offset = 85, value = "z"}), Colon, Type (TokenInfo{offset = 89, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 96, value = "Int"}), LeftSquirly, Ident (TokenInfo{offset = 110, value = "x"}), Assign, Ident (TokenInfo{offset = 115, value = "y"}), Assign, Ident (TokenInfo{offset = 120, value = "z"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "x"}) (TokenInfo{offset = 18, value = "Int"}) Nothing, MethodDefinition (TokenInfo{offset = 28, value = "f"}) [Formal (TokenInfo{offset = 30, value = "y"}) (TokenInfo{offset = 34, value = "Int"})] (TokenInfo{offset = 41, value = "Int"}) (AssignStatement (TokenInfo{offset = 55, value = "x"}) (IdentStatement (TokenInfo{offset = 60, value = "y"}))), MethodDefinition (TokenInfo{offset = 74, value = "f"}) [Formal (TokenInfo{offset = 76, value = "y"}) (TokenInfo{offset = 80, value = "Int"}), Formal (TokenInfo{offset = 85, value = "z"}) (TokenInfo{offset = 89, value = "Int"})] (TokenInfo{offset = 96, value = "Int"}) (AssignStatement (TokenInfo{offset = 110, value = "x"}) (AssignStatement (TokenInfo{offset = 115, value = "y"}) (IdentStatement (TokenInfo{offset = 120, value = "z"}))))]])

testNewIsVoid :: Ast -> Spec
testNewIsVoid ast = do
    describe "Parser" $ do
        it "should ast new isvoid" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 20, value = "Bool"}), LeftSquirly, Not, IsVoid, New, Type (TokenInfo{offset = 50, value = "A"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [] (TokenInfo{offset = 20, value = "Bool"}) (NotStatement (IsVoidStatement (NewStatement (TokenInfo{offset = 50, value = "A"}))))]])

testDispatch :: Ast -> Spec
testDispatch ast = do
    describe "Parser" $ do
        it "should ast dispatch" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Bool"}), LeftSquirly, Ident (TokenInfo{offset = 42, value = "f"}), LeftParen, Ident (TokenInfo{offset = 44, value = "x"}), Plus, Integer (TokenInfo{offset = 48, value = 1}), RightParen, RightSquirly, SemiColon, Ident (TokenInfo{offset = 63, value = "g"}), LeftParen, Ident (TokenInfo{offset = 65, value = "x"}), Colon, Type (TokenInfo{offset = 69, value = "Int"}), Comma, Ident (TokenInfo{offset = 74, value = "y"}), Colon, Type (TokenInfo{offset = 78, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 85, value = "Bool"}), LeftSquirly, Ident (TokenInfo{offset = 100, value = "self"}), Dot, Ident (TokenInfo{offset = 105, value = "g"}), LeftParen, Ident (TokenInfo{offset = 107, value = "x"}), Plus, Integer (TokenInfo{offset = 111, value = 1}), Comma, Ident (TokenInfo{offset = 114, value = "y"}), Plus, Integer (TokenInfo{offset = 118, value = 1}), RightParen, RightSquirly, SemiColon, Ident (TokenInfo{offset = 133, value = "h"}), LeftParen, Ident (TokenInfo{offset = 135, value = "x"}), Colon, Type (TokenInfo{offset = 139, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 146, value = "A"}), LeftSquirly, New, Type (TokenInfo{offset = 162, value = "A"}), At, Type (TokenInfo{offset = 164, value = "A"}), Dot, Ident (TokenInfo{offset = 166, value = "h"}), LeftParen, Ident (TokenInfo{offset = 168, value = "x"}), Plus, Integer (TokenInfo{offset = 172, value = 1}), RightParen, Dot, Ident (TokenInfo{offset = 175, value = "h"}), LeftParen, Ident (TokenInfo{offset = 177, value = "x"}), Plus, Integer (TokenInfo{offset = 181, value = 2}), RightParen, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Int"})] (TokenInfo{offset = 27, value = "Bool"}) (MethodCall Nothing Nothing (TokenInfo{offset = 42, value = "f"}) [AddStatement (IdentStatement (TokenInfo{offset = 44, value = "x"})) (IntegerLiteral (TokenInfo{offset = 48, value = 1}))]), MethodDefinition (TokenInfo{offset = 63, value = "g"}) [Formal (TokenInfo{offset = 65, value = "x"}) (TokenInfo{offset = 69, value = "Int"}), Formal (TokenInfo{offset = 74, value = "y"}) (TokenInfo{offset = 78, value = "Int"})] (TokenInfo{offset = 85, value = "Bool"}) (MethodCall (Just (IdentStatement (TokenInfo{offset = 100, value = "self"}))) Nothing (TokenInfo{offset = 105, value = "g"}) [AddStatement (IdentStatement (TokenInfo{offset = 107, value = "x"})) (IntegerLiteral (TokenInfo{offset = 111, value = 1})), AddStatement (IdentStatement (TokenInfo{offset = 114, value = "y"})) (IntegerLiteral (TokenInfo{offset = 118, value = 1}))]), MethodDefinition (TokenInfo{offset = 133, value = "h"}) [Formal (TokenInfo{offset = 135, value = "x"}) (TokenInfo{offset = 139, value = "Int"})] (TokenInfo{offset = 146, value = "A"}) (MethodCall (Just (MethodCall (Just (NewStatement (TokenInfo{offset = 162, value = "A"}))) (Just (TokenInfo{offset = 164, value = "A"})) (TokenInfo{offset = 166, value = "h"}) [AddStatement (IdentStatement (TokenInfo{offset = 168, value = "x"})) (IntegerLiteral (TokenInfo{offset = 172, value = 1}))])) Nothing (TokenInfo{offset = 175, value = "h"}) [AddStatement (IdentStatement (TokenInfo{offset = 177, value = "x"})) (IntegerLiteral (TokenInfo{offset = 181, value = 2}))])]])

testIf :: Ast -> Spec
testIf ast = do
    describe "Parser" $ do
        it "should ast if" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Int"}), LeftSquirly, If, Ident (TokenInfo{offset = 44, value = "x"}), LessEqual, Integer (TokenInfo{offset = 49, value = 5}), Then, Ident (TokenInfo{offset = 56, value = "x"}), Else, Ident (TokenInfo{offset = 63, value = "x"}), Plus, Integer (TokenInfo{offset = 67, value = 1}), Fi, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Int"})] (TokenInfo{offset = 27, value = "Int"}) (IfStatement (LessThanOrEqualStatement (IdentStatement (TokenInfo{offset = 44, value = "x"})) (IntegerLiteral (TokenInfo{offset = 49, value = 5}))) (IdentStatement (TokenInfo{offset = 56, value = "x"})) (AddStatement (IdentStatement (TokenInfo{offset = 63, value = "x"})) (IntegerLiteral (TokenInfo{offset = 67, value = 1}))))]])

testWhile :: Ast -> Spec
testWhile ast = do
    describe "Parser" $ do
        it "should ast while" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Object"}), LeftSquirly, While, Integer (TokenInfo{offset = 50, value = 0}), LessThan, Ident (TokenInfo{offset = 54, value = "x"}), Loop, Ident (TokenInfo{offset = 73, value = "x"}), Assign, Ident (TokenInfo{offset = 78, value = "x"}), Minus, Integer (TokenInfo{offset = 82, value = 1}), Pool, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Int"})] (TokenInfo{offset = 27, value = "Object"}) (WhileStatement (LessThanStatement (IntegerLiteral (TokenInfo{offset = 50, value = 0})) (IdentStatement (TokenInfo{offset = 54, value = "x"}))) (AssignStatement (TokenInfo{offset = 73, value = "x"}) (SubStatement (IdentStatement (TokenInfo{offset = 78, value = "x"})) (IntegerLiteral (TokenInfo{offset = 82, value = 1})))))]])

testLet :: Ast -> Spec
testLet ast = do
    describe "Parser" $ do
        it "should ast let" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "Int"}), LeftSquirly, Let, Ident (TokenInfo{offset = 45, value = "x"}), Colon, Type (TokenInfo{offset = 49, value = "Int"}), Assign, Ident (TokenInfo{offset = 56, value = "x"}), Plus, Integer (TokenInfo{offset = 60, value = 1}), Comma, Ident (TokenInfo{offset = 75, value = "y"}), Colon, Type (TokenInfo{offset = 79, value = "Int"}), Assign, Ident (TokenInfo{offset = 86, value = "x"}), Plus, Integer (TokenInfo{offset = 90, value = 1}), In, Ident (TokenInfo{offset = 115, value = "x"}), RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Int"})] (TokenInfo{offset = 27, value = "Int"}) (LetStatement [VariableDefinition (TokenInfo{offset = 45, value = "x"}) (TokenInfo{offset = 49, value = "Int"}) (Just (AddStatement (IdentStatement (TokenInfo{offset = 56, value = "x"})) (IntegerLiteral (TokenInfo{offset = 60, value = 1})))), VariableDefinition (TokenInfo{offset = 75, value = "y"}) (TokenInfo{offset = 79, value = "Int"}) (Just (AddStatement (IdentStatement (TokenInfo{offset = 86, value = "x"})) (IntegerLiteral (TokenInfo{offset = 90, value = 1}))))] (IdentStatement (TokenInfo{offset = 115, value = "x"})))]])

testCase :: Ast -> Spec
testCase ast = do
    describe "Parser" $ do
        it "should ast case" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Object"}), RightParen, Colon, Type (TokenInfo{offset = 30, value = "String"}), LeftSquirly, Case, Ident (TokenInfo{offset = 52, value = "x"}), Of, Ident (TokenInfo{offset = 69, value = "s"}), Colon, Type (TokenInfo{offset = 73, value = "String"}), Results, String (TokenInfo{offset = 83, value = "String"}), SemiColon, Ident (TokenInfo{offset = 105, value = "i"}), Colon, Type (TokenInfo{offset = 109, value = "Int"}), Results, String (TokenInfo{offset = 119, value = "Int"}), SemiColon, Ident (TokenInfo{offset = 138, value = "o"}), Colon, Type (TokenInfo{offset = 142, value = "Object"}), Results, String (TokenInfo{offset = 152, value = "Oops"}), SemiColon, Esac, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Object"})] (TokenInfo{offset = 30, value = "String"}) (CaseStatement (IdentStatement (TokenInfo{offset = 52, value = "x"})) [CaseOfDefinition (TokenInfo{offset = 69, value = "s"}) (TokenInfo{offset = 73, value = "String"}) (StringLiteral (TokenInfo{offset = 83, value = "String"})), CaseOfDefinition (TokenInfo{offset = 105, value = "i"}) (TokenInfo{offset = 109, value = "Int"}) (StringLiteral (TokenInfo{offset = 119, value = "Int"})), CaseOfDefinition (TokenInfo{offset = 138, value = "o"}) (TokenInfo{offset = 142, value = "Object"}) (StringLiteral (TokenInfo{offset = 152, value = "Oops"}))])]])

testBlock :: Ast -> Spec
testBlock ast = do
    describe "Parser" $ do
        it "should ast block" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "f"}), LeftParen, Ident (TokenInfo{offset = 16, value = "x"}), Colon, Type (TokenInfo{offset = 20, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 27, value = "String"}), LeftSquirly, LeftSquirly, Ident (TokenInfo{offset = 58, value = "x"}), Assign, Ident (TokenInfo{offset = 63, value = "x"}), Plus, Integer (TokenInfo{offset = 67, value = 1}), SemiColon, String (TokenInfo{offset = 82, value = "Done!"}), SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [MethodDefinition (TokenInfo{offset = 14, value = "f"}) [Formal (TokenInfo{offset = 16, value = "x"}) (TokenInfo{offset = 20, value = "Int"})] (TokenInfo{offset = 27, value = "String"}) (BlockStatement [AssignStatement (TokenInfo{offset = 58, value = "x"}) (AddStatement (IdentStatement (TokenInfo{offset = 63, value = "x"})) (IntegerLiteral (TokenInfo{offset = 67, value = 1}))), StringLiteral (TokenInfo{offset = 82, value = "Done!"})])]])

testStringSpecialChars :: Ast -> Spec
testStringSpecialChars ast = do
    describe "Parser" $ do
        it "should ast string with special chars" $
            do
                ast [Class, Type (TokenInfo{offset = 6, value = "A"}), LeftSquirly, Ident (TokenInfo{offset = 14, value = "s1"}), Colon, Type (TokenInfo{offset = 19, value = "String"}), Assign, String (TokenInfo{offset = 29, value = "ab\tcd"}), SemiColon, Ident (TokenInfo{offset = 43, value = "s2"}), Colon, Type (TokenInfo{offset = 48, value = "String"}), Assign, String (TokenInfo{offset = 58, value = "ab\ncd"}), SemiColon, Ident (TokenInfo{offset = 72, value = "s3"}), Colon, Type (TokenInfo{offset = 77, value = "String"}), Assign, String (TokenInfo{offset = 87, value = "ab\ncd"}), SemiColon, Ident (TokenInfo{offset = 101, value = "s4"}), Colon, Type (TokenInfo{offset = 106, value = "String"}), Assign, String (TokenInfo{offset = 116, value = "ab\\cd"}), SemiColon, Ident (TokenInfo{offset = 130, value = "s5"}), Colon, Type (TokenInfo{offset = 135, value = "String"}), Assign, String (TokenInfo{offset = 145, value = "abzcd"}), SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 6, value = "A"}) Nothing [AttributeDefinition (TokenInfo{offset = 14, value = "s1"}) (TokenInfo{offset = 19, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 29, value = "ab\tcd"}))), AttributeDefinition (TokenInfo{offset = 43, value = "s2"}) (TokenInfo{offset = 48, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 58, value = "ab\ncd"}))), AttributeDefinition (TokenInfo{offset = 72, value = "s3"}) (TokenInfo{offset = 77, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 87, value = "ab\ncd"}))), AttributeDefinition (TokenInfo{offset = 101, value = "s4"}) (TokenInfo{offset = 106, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 116, value = "ab\\cd"}))), AttributeDefinition (TokenInfo{offset = 130, value = "s5"}) (TokenInfo{offset = 135, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 145, value = "abzcd"})))]])

testBig :: Ast -> Spec
testBig ast = do
    describe "Parser" $ do
        it "should ast big text" $
            do
                ast [Class, Type (TokenInfo{offset = 190, value = "List"}), Inherits, Type (TokenInfo{offset = 204, value = "IO"}), LeftSquirly, Ident (TokenInfo{offset = 213, value = "elem"}), Colon, Type (TokenInfo{offset = 220, value = "Object"}), SemiColon, Ident (TokenInfo{offset = 232, value = "next"}), Colon, Type (TokenInfo{offset = 239, value = "List"}), SemiColon, Ident (TokenInfo{offset = 250, value = "init"}), LeftParen, Ident (TokenInfo{offset = 255, value = "e"}), Colon, Type (TokenInfo{offset = 259, value = "Object"}), Comma, Ident (TokenInfo{offset = 267, value = "n"}), Colon, Type (TokenInfo{offset = 271, value = "List"}), RightParen, Colon, Type (TokenInfo{offset = 279, value = "List"}), LeftSquirly, LeftSquirly, Ident (TokenInfo{offset = 308, value = "elem"}), Assign, Ident (TokenInfo{offset = 316, value = "e"}), SemiColon, Ident (TokenInfo{offset = 331, value = "next"}), Assign, Ident (TokenInfo{offset = 339, value = "n"}), SemiColon, Ident (TokenInfo{offset = 354, value = "self"}), SemiColon, RightSquirly, RightSquirly, SemiColon, Ident (TokenInfo{offset = 382, value = "print"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 392, value = "IO"}), LeftSquirly, Let, Ident (TokenInfo{offset = 409, value = "str"}), Colon, Type (TokenInfo{offset = 415, value = "String"}), Assign, Case, Ident (TokenInfo{offset = 672, value = "elem"}), Of, Ident (TokenInfo{offset = 700, value = "s"}), Colon, Type (TokenInfo{offset = 704, value = "String"}), Results, Ident (TokenInfo{offset = 714, value = "s"}), SemiColon, Ident (TokenInfo{offset = 737, value = "n"}), Colon, Type (TokenInfo{offset = 741, value = "Int"}), Results, New, Type (TokenInfo{offset = 752, value = "A2I"}), Dot, Ident (TokenInfo{offset = 756, value = "i2a"}), LeftParen, Ident (TokenInfo{offset = 760, value = "n"}), RightParen, SemiColon, Ident (TokenInfo{offset = 814, value = "o"}), Colon, Type (TokenInfo{offset = 818, value = "Object"}), Results, LeftSquirly, Ident (TokenInfo{offset = 830, value = "abort"}), LeftParen, RightParen, SemiColon, String (TokenInfo{offset = 839, value = ""}), SemiColon, RightSquirly, SemiColon, Esac, In, LeftSquirly, Ident (TokenInfo{offset = 908, value = "out_string"}), LeftParen, Ident (TokenInfo{offset = 919, value = "str"}), Dot, Ident (TokenInfo{offset = 923, value = "concat"}), LeftParen, String (TokenInfo{offset = 930, value = " "}), RightParen, RightParen, SemiColon, If, LeftParen, IsVoid, Ident (TokenInfo{offset = 964, value = "next"}), RightParen, Then, Ident (TokenInfo{offset = 975, value = "out_string"}), LeftParen, String (TokenInfo{offset = 986, value = "\n"}), RightParen, Else, Ident (TokenInfo{offset = 997, value = "next"}), Dot, Ident (TokenInfo{offset = 1002, value = "print"}), LeftParen, RightParen, Fi, SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Class, Type (TokenInfo{offset = 1045, value = "Main"}), Inherits, Type (TokenInfo{offset = 1059, value = "IO"}), LeftSquirly, Ident (TokenInfo{offset = 1068, value = "main"}), LeftParen, RightParen, Colon, Type (TokenInfo{offset = 1077, value = "Object"}), LeftSquirly, LeftSquirly, Let, Ident (TokenInfo{offset = 1112, value = "x"}), Colon, Type (TokenInfo{offset = 1116, value = "Int"}), Assign, Integer (TokenInfo{offset = 1123, value = 0}), Comma, Ident (TokenInfo{offset = 1142, value = "y"}), Colon, Type (TokenInfo{offset = 1146, value = "String"}), Assign, String (TokenInfo{offset = 1156, value = "!"}), Comma, Ident (TokenInfo{offset = 1177, value = "z"}), Colon, Type (TokenInfo{offset = 1181, value = "Int"}), Assign, Ident (TokenInfo{offset = 1188, value = "x"}), Plus, Integer (TokenInfo{offset = 1192, value = 2}), Comma, Ident (TokenInfo{offset = 1211, value = "empty"}), Colon, Type (TokenInfo{offset = 1219, value = "List"}), Comma, Ident (TokenInfo{offset = 1275, value = "list"}), Colon, Type (TokenInfo{offset = 1282, value = "List"}), Assign, New, Type (TokenInfo{offset = 1314, value = "List"}), Dot, Ident (TokenInfo{offset = 1319, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1324, value = "x"}), Comma, New, Type (TokenInfo{offset = 1355, value = "List"}), Dot, Ident (TokenInfo{offset = 1360, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1365, value = "y"}), Comma, New, Type (TokenInfo{offset = 1400, value = "List"}), Dot, Ident (TokenInfo{offset = 1405, value = "init"}), LeftParen, Ident (TokenInfo{offset = 1410, value = "z"}), Comma, Ident (TokenInfo{offset = 1413, value = "empty"}), RightParen, RightParen, RightParen, In, Ident (TokenInfo{offset = 1453, value = "list"}), Dot, Ident (TokenInfo{offset = 1458, value = "print"}), LeftParen, RightParen, SemiColon, Let, Ident (TokenInfo{offset = 1561, value = "n"}), Colon, Type (TokenInfo{offset = 1565, value = "Int"}), Assign, Ident (TokenInfo{offset = 1572, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1583, value = "Calcul\259m factorial pentru: "}), RightParen, Dot, Ident (TokenInfo{offset = 1614, value = "in_int"}), LeftParen, RightParen, In, LeftSquirly, Ident (TokenInfo{offset = 1676, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1687, value = "Factorial recursiv: "}), RightParen, Dot, Ident (TokenInfo{offset = 1711, value = "out_int"}), LeftParen, Ident (TokenInfo{offset = 1719, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 1728, value = "n"}), RightParen, RightParen, Dot, Ident (TokenInfo{offset = 1757, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1768, value = "\n"}), RightParen, SemiColon, Ident (TokenInfo{offset = 1795, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1806, value = "Factorial iterativ: "}), RightParen, Dot, Ident (TokenInfo{offset = 1830, value = "out_int"}), LeftParen, Ident (TokenInfo{offset = 1838, value = "fact_iter"}), LeftParen, Ident (TokenInfo{offset = 1848, value = "n"}), RightParen, RightParen, Dot, Ident (TokenInfo{offset = 1877, value = "out_string"}), LeftParen, String (TokenInfo{offset = 1888, value = "\n"}), RightParen, SemiColon, RightSquirly, SemiColon, RightSquirly, RightSquirly, SemiColon, Ident (TokenInfo{offset = 1974, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 1983, value = "n"}), Colon, Type (TokenInfo{offset = 1987, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 1994, value = "Int"}), LeftSquirly, If, Ident (TokenInfo{offset = 2011, value = "n"}), Equal, Integer (TokenInfo{offset = 2015, value = 0}), Then, Integer (TokenInfo{offset = 2022, value = 1}), Else, Ident (TokenInfo{offset = 2029, value = "n"}), Asterisk, Ident (TokenInfo{offset = 2033, value = "fact_rec"}), LeftParen, Ident (TokenInfo{offset = 2042, value = "n"}), Minus, Integer (TokenInfo{offset = 2046, value = 1}), RightParen, Fi, RightSquirly, SemiColon, Ident (TokenInfo{offset = 2102, value = "fact_iter"}), LeftParen, Ident (TokenInfo{offset = 2112, value = "n"}), Colon, Type (TokenInfo{offset = 2116, value = "Int"}), RightParen, Colon, Type (TokenInfo{offset = 2123, value = "Int"}), LeftSquirly, Let, Ident (TokenInfo{offset = 2141, value = "res"}), Colon, Type (TokenInfo{offset = 2147, value = "Int"}), Assign, Integer (TokenInfo{offset = 2154, value = 1}), In, LeftSquirly, While, LeftParen, Not, LeftParen, Ident (TokenInfo{offset = 2329, value = "n"}), Equal, Integer (TokenInfo{offset = 2333, value = 0}), RightParen, RightParen, Loop, LeftSquirly, Ident (TokenInfo{offset = 2388, value = "res"}), Assign, Ident (TokenInfo{offset = 2395, value = "res"}), Asterisk, Ident (TokenInfo{offset = 2401, value = "n"}), SemiColon, Ident (TokenInfo{offset = 2428, value = "n"}), Assign, Ident (TokenInfo{offset = 2433, value = "n"}), Minus, Integer (TokenInfo{offset = 2437, value = 1}), SemiColon, RightSquirly, Pool, SemiColon, Ident (TokenInfo{offset = 2500, value = "res"}), SemiColon, RightSquirly, RightSquirly, SemiColon, RightSquirly, SemiColon, Eof]
                `shouldBe` Right (Program [ClassDefinition (TokenInfo{offset = 190, value = "List"}) (Just (TokenInfo{offset = 204, value = "IO"})) [AttributeDefinition (TokenInfo{offset = 213, value = "elem"}) (TokenInfo{offset = 220, value = "Object"}) Nothing, AttributeDefinition (TokenInfo{offset = 232, value = "next"}) (TokenInfo{offset = 239, value = "List"}) Nothing, MethodDefinition (TokenInfo{offset = 250, value = "init"}) [Formal (TokenInfo{offset = 255, value = "e"}) (TokenInfo{offset = 259, value = "Object"}), Formal (TokenInfo{offset = 267, value = "n"}) (TokenInfo{offset = 271, value = "List"})] (TokenInfo{offset = 279, value = "List"}) (BlockStatement [AssignStatement (TokenInfo{offset = 308, value = "elem"}) (IdentStatement (TokenInfo{offset = 316, value = "e"})), AssignStatement (TokenInfo{offset = 331, value = "next"}) (IdentStatement (TokenInfo{offset = 339, value = "n"})), IdentStatement (TokenInfo{offset = 354, value = "self"})]), MethodDefinition (TokenInfo{offset = 382, value = "print"}) [] (TokenInfo{offset = 392, value = "IO"}) (LetStatement [VariableDefinition (TokenInfo{offset = 409, value = "str"}) (TokenInfo{offset = 415, value = "String"}) (Just (CaseStatement (IdentStatement (TokenInfo{offset = 672, value = "elem"})) [CaseOfDefinition (TokenInfo{offset = 700, value = "s"}) (TokenInfo{offset = 704, value = "String"}) (IdentStatement (TokenInfo{offset = 714, value = "s"})), CaseOfDefinition (TokenInfo{offset = 737, value = "n"}) (TokenInfo{offset = 741, value = "Int"}) (MethodCall (Just (NewStatement (TokenInfo{offset = 752, value = "A2I"}))) Nothing (TokenInfo{offset = 756, value = "i2a"}) [IdentStatement (TokenInfo{offset = 760, value = "n"})]), CaseOfDefinition (TokenInfo{offset = 814, value = "o"}) (TokenInfo{offset = 818, value = "Object"}) (BlockStatement [MethodCall Nothing Nothing (TokenInfo{offset = 830, value = "abort"}) [], StringLiteral (TokenInfo{offset = 839, value = ""})])]))] (BlockStatement [MethodCall Nothing Nothing (TokenInfo{offset = 908, value = "out_string"}) [MethodCall (Just (IdentStatement (TokenInfo{offset = 919, value = "str"}))) Nothing (TokenInfo{offset = 923, value = "concat"}) [StringLiteral (TokenInfo{offset = 930, value = " "})]], IfStatement (IsVoidStatement (IdentStatement (TokenInfo{offset = 964, value = "next"}))) (MethodCall Nothing Nothing (TokenInfo{offset = 975, value = "out_string"}) [StringLiteral (TokenInfo{offset = 986, value = "\n"})]) (MethodCall (Just (IdentStatement (TokenInfo{offset = 997, value = "next"}))) Nothing (TokenInfo{offset = 1002, value = "print"}) [])]))], ClassDefinition (TokenInfo{offset = 1045, value = "Main"}) (Just (TokenInfo{offset = 1059, value = "IO"})) [MethodDefinition (TokenInfo{offset = 1068, value = "main"}) [] (TokenInfo{offset = 1077, value = "Object"}) (BlockStatement [LetStatement [VariableDefinition (TokenInfo{offset = 1112, value = "x"}) (TokenInfo{offset = 1116, value = "Int"}) (Just (IntegerLiteral (TokenInfo{offset = 1123, value = 0}))), VariableDefinition (TokenInfo{offset = 1142, value = "y"}) (TokenInfo{offset = 1146, value = "String"}) (Just (StringLiteral (TokenInfo{offset = 1156, value = "!"}))), VariableDefinition (TokenInfo{offset = 1177, value = "z"}) (TokenInfo{offset = 1181, value = "Int"}) (Just (AddStatement (IdentStatement (TokenInfo{offset = 1188, value = "x"})) (IntegerLiteral (TokenInfo{offset = 1192, value = 2})))), VariableDefinition (TokenInfo{offset = 1211, value = "empty"}) (TokenInfo{offset = 1219, value = "List"}) Nothing, VariableDefinition (TokenInfo{offset = 1275, value = "list"}) (TokenInfo{offset = 1282, value = "List"}) (Just (MethodCall (Just (NewStatement (TokenInfo{offset = 1314, value = "List"}))) Nothing (TokenInfo{offset = 1319, value = "init"}) [IdentStatement (TokenInfo{offset = 1324, value = "x"}), MethodCall (Just (NewStatement (TokenInfo{offset = 1355, value = "List"}))) Nothing (TokenInfo{offset = 1360, value = "init"}) [IdentStatement (TokenInfo{offset = 1365, value = "y"}), MethodCall (Just (NewStatement (TokenInfo{offset = 1400, value = "List"}))) Nothing (TokenInfo{offset = 1405, value = "init"}) [IdentStatement (TokenInfo{offset = 1410, value = "z"}), IdentStatement (TokenInfo{offset = 1413, value = "empty"})]]]))] (MethodCall (Just (IdentStatement (TokenInfo{offset = 1453, value = "list"}))) Nothing (TokenInfo{offset = 1458, value = "print"}) []), LetStatement [VariableDefinition (TokenInfo{offset = 1561, value = "n"}) (TokenInfo{offset = 1565, value = "Int"}) (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo{offset = 1572, value = "out_string"}) [StringLiteral (TokenInfo{offset = 1583, value = "Calcul\259m factorial pentru: "})])) Nothing (TokenInfo{offset = 1614, value = "in_int"}) []))] (BlockStatement [MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo{offset = 1676, value = "out_string"}) [StringLiteral (TokenInfo{offset = 1687, value = "Factorial recursiv: "})])) Nothing (TokenInfo{offset = 1711, value = "out_int"}) [MethodCall Nothing Nothing (TokenInfo{offset = 1719, value = "fact_rec"}) [IdentStatement (TokenInfo{offset = 1728, value = "n"})]])) Nothing (TokenInfo{offset = 1757, value = "out_string"}) [StringLiteral (TokenInfo{offset = 1768, value = "\n"})], MethodCall (Just (MethodCall (Just (MethodCall Nothing Nothing (TokenInfo{offset = 1795, value = "out_string"}) [StringLiteral (TokenInfo{offset = 1806, value = "Factorial iterativ: "})])) Nothing (TokenInfo{offset = 1830, value = "out_int"}) [MethodCall Nothing Nothing (TokenInfo{offset = 1838, value = "fact_iter"}) [IdentStatement (TokenInfo{offset = 1848, value = "n"})]])) Nothing (TokenInfo{offset = 1877, value = "out_string"}) [StringLiteral (TokenInfo{offset = 1888, value = "\n"})]])]), MethodDefinition (TokenInfo{offset = 1974, value = "fact_rec"}) [Formal (TokenInfo{offset = 1983, value = "n"}) (TokenInfo{offset = 1987, value = "Int"})] (TokenInfo{offset = 1994, value = "Int"}) (IfStatement (EqualStatement (IdentStatement (TokenInfo{offset = 2011, value = "n"})) (IntegerLiteral (TokenInfo{offset = 2015, value = 0}))) (IntegerLiteral (TokenInfo{offset = 2022, value = 1})) (MulStatement (IdentStatement (TokenInfo{offset = 2029, value = "n"})) (MethodCall Nothing Nothing (TokenInfo{offset = 2033, value = "fact_rec"}) [SubStatement (IdentStatement (TokenInfo{offset = 2042, value = "n"})) (IntegerLiteral (TokenInfo{offset = 2046, value = 1}))]))), MethodDefinition (TokenInfo{offset = 2102, value = "fact_iter"}) [Formal (TokenInfo{offset = 2112, value = "n"}) (TokenInfo{offset = 2116, value = "Int"})] (TokenInfo{offset = 2123, value = "Int"}) (LetStatement [VariableDefinition (TokenInfo{offset = 2141, value = "res"}) (TokenInfo{offset = 2147, value = "Int"}) (Just (IntegerLiteral (TokenInfo{offset = 2154, value = 1})))] (BlockStatement [WhileStatement (NotStatement (EqualStatement (IdentStatement (TokenInfo{offset = 2329, value = "n"})) (IntegerLiteral (TokenInfo{offset = 2333, value = 0})))) (BlockStatement [AssignStatement (TokenInfo{offset = 2388, value = "res"}) (MulStatement (IdentStatement (TokenInfo{offset = 2395, value = "res"})) (IdentStatement (TokenInfo{offset = 2401, value = "n"}))), AssignStatement (TokenInfo{offset = 2428, value = "n"}) (SubStatement (IdentStatement (TokenInfo{offset = 2433, value = "n"})) (IntegerLiteral (TokenInfo{offset = 2437, value = 1})))]), IdentStatement (TokenInfo{offset = 2500, value = "res"})]))]])
